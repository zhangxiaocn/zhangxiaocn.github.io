{"meta":{"title":"ZhangXiao's Blog","subtitle":"清风湿润，茶烟轻扬。","description":null,"author":"Zhang Xiao","url":"https://zhangxiaocn.github.io","root":"/"},"pages":[{"title":"关于","date":"2020-01-09T04:06:02.357Z","updated":"2020-01-09T04:06:02.357Z","comments":false,"path":"about/index.html","permalink":"https://zhangxiaocn.github.io/about/index.html","excerpt":"","text":"一名在校大学生，目前正在学习 ROS 相关知识。 联系邮箱：mailto:zhangxiaoim@foxmail.com 欢迎关注我的个人公众号：是你鸭鸭"},{"title":"分类","date":"2020-01-07T13:19:57.000Z","updated":"2020-01-07T13:40:30.049Z","comments":true,"path":"categories/index.html","permalink":"https://zhangxiaocn.github.io/categories/index.html","excerpt":"","text":""},{"title":"友链","date":"2020-01-07T13:20:22.000Z","updated":"2020-01-07T13:39:26.827Z","comments":true,"path":"link/index.html","permalink":"https://zhangxiaocn.github.io/link/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-01-07T13:18:39.000Z","updated":"2020-01-07T13:40:13.172Z","comments":true,"path":"tags/index.html","permalink":"https://zhangxiaocn.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"TF 坐标变换（跟踪小海龟例程）","slug":"ros-tf","date":"2019-12-02T12:29:00.000Z","updated":"2020-01-18T06:01:07.737Z","comments":true,"path":"2019/12/02/ros-tf/","link":"","permalink":"https://zhangxiaocn.github.io/2019/12/02/ros-tf/","excerpt":"","text":"笔记整理记录自：https://www.bilibili.com/video/av69417218 1、新建工作空间 新建 catkin_ws 文件：mkdir -p catkin_ws/src 进入 catkin_ws 目录：cd catkin_ws 初始化：catkin_make 进入 src 文件：cd src 创建用于通信的 package：catkin_create_pkg learning_tf std_msgs rospy roscpp 编译一下：catkin_make 添加 source：echo &quot;source ~/catkin_ws/devel/setup.zsh &quot; &gt;&gt; ~/.zshrc 返回根目录：cd 查看 source 是否添加：gedit .zshrc 或者 vi .zshrc 2、创建编程文件 找到刚才的工作空间：cd ~/catkin_ws/src/learning_tf/src 新建 turtle_tf_broadcaster.cpp 文件：gedit turtle_tf_broadcaster.cpp 保存如下代码： c++1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;ros/ros.h&gt;#include &lt;tf/transform_broadcaster.h&gt;#include &lt;turtlesim/Pose.h&gt;std::string turtle_name;void poseCallback(const turtlesim::PoseConstPtr&amp; msg)&#123; // tf广播器 static tf::TransformBroadcaster br; // 根据乌龟当前的位姿，设置相对于世界坐标系的坐标变换 tf::Transform transform; transform.setOrigin( tf::Vector3(msg-&gt;x, msg-&gt;y, 0.0) ); tf::Quaternion q; q.setRPY(0, 0, msg-&gt;theta); transform.setRotation(q); // 发布坐标变换 br.sendTransform(tf::StampedTransform(transform, ros::Time::now(), \"world\", turtle_name));&#125;int main(int argc, char** argv)&#123; // 初始化节点 ros::init(argc, argv, \"my_tf_broadcaster\"); if (argc != 2) &#123; ROS_ERROR(\"need turtle name as argument\"); return -1; &#125;; turtle_name = argv[1]; // 订阅乌龟的pose信息 ros::NodeHandle node; ros::Subscriber sub = node.subscribe(turtle_name+\"/pose\", 10, &amp;poseCallback); ros::spin(); return 0;&#125;; 新建 turtle_tf_listener.cpp 文件：gedit turtle_tf_listener.cpp 保存如下代码： c++1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;ros/ros.h&gt;#include &lt;tf/transform_listener.h&gt;#include &lt;geometry_msgs/Twist.h&gt;#include &lt;turtlesim/Spawn.h&gt;int main(int argc, char** argv)&#123; // 初始化节点 ros::init(argc, argv, \"my_tf_listener\"); ros::NodeHandle node; // 通过服务调用，产生第二只乌龟turtle2 ros::service::waitForService(\"spawn\"); ros::ServiceClient add_turtle = node.serviceClient&lt;turtlesim::Spawn&gt;(\"spawn\"); turtlesim::Spawn srv; add_turtle.call(srv); // 定义turtle2的速度控制发布器 ros::Publisher turtle_vel = node.advertise&lt;geometry_msgs::Twist&gt;(\"turtle2/cmd_vel\", 10); // tf监听器 tf::TransformListener listener; ros::Rate rate(10.0); while (node.ok()) &#123; tf::StampedTransform transform; try &#123; // 查找turtle2与turtle1的坐标变换 listener.waitForTransform(\"/turtle2\", \"/turtle1\", ros::Time(0), ros::Duration(3.0)); listener.lookupTransform(\"/turtle2\", \"/turtle1\", ros::Time(0), transform); &#125; catch (tf::TransformException &amp;ex) &#123; ROS_ERROR(\"%s\",ex.what()); ros::Duration(1.0).sleep(); continue; &#125; // 根据turtle1和turtle2之间的坐标变换，计算turtle2需要运动的线速度和角速度 // 并发布速度控制指令，使turtle2向turtle1移动 geometry_msgs::Twist vel_msg; vel_msg.angular.z = 4.0 * atan2(transform.getOrigin().y(), transform.getOrigin().x()); vel_msg.linear.x = 0.5 * sqrt(pow(transform.getOrigin().x(), 2) + pow(transform.getOrigin().y(), 2)); turtle_vel.publish(vel_msg); rate.sleep(); &#125; return 0;&#125;; 3、配置 找到刚才的工作空间：cd ~/catkin_ws/src/learning_tf/ 编辑 CMakeLists.txt 文件：gedit CMakeLists.txt 保存如下代码： Code1234567find_package(.... tf)add_executable(turtle_tf_broadcaster src/turtle_tf_broadcaster.cpp)target_link_libraries(turtle_tf_broadcaster $&#123;catkin_LIBRARIES&#125;)add_executable(turtle_tf_listener src/turtle_tf_listener.cpp)target_link_libraries(turtle_tf_listener $&#123;catkin_LIBRARIES&#125;) 返回主目录：cd ~/catkin_ws/ 编译一下：catkin_make 4、创建 launch 文件 找到刚才的工作空间：cd ~/catkin_ws/src/learning_tf/ 新建 launch 文件夹：mkdir launch 新建文件：gedit start_demo_with_listener.launch 保存如下代码： html123456789101112131415161718&lt;launch&gt; &lt;!-- 海龟仿真器 --&gt; &lt;node pkg=\"turtlesim\" type=\"turtlesim_node\" name=\"sim\"/&gt; &lt;!-- 键盘控制 --&gt; &lt;node pkg=\"turtlesim\" type=\"turtle_teleop_key\" name=\"teleop\" output=\"screen\"/&gt; &lt;!-- 两只海龟的tf广播 --&gt; &lt;node pkg=\"learning_tf\" type=\"turtle_tf_broadcaster\" args=\"/turtle1\" name=\"turtle1_tf_broadcaster\" /&gt; &lt;node pkg=\"learning_tf\" type=\"turtle_tf_broadcaster\" args=\"/turtle2\" name=\"turtle2_tf_broadcaster\" /&gt; &lt;!-- 监听tf广播，并且控制turtle2移动 --&gt; &lt;node pkg=\"learning_tf\" type=\"turtle_tf_listener\" name=\"listener\" /&gt;&lt;/launch&gt; 5、运行 启动 launch 坐标文件：roslaunch learning_tf start_demo_with_listener.launch 通过按键控制海龟即可","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://zhangxiaocn.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"ROS","slug":"ROS","permalink":"https://zhangxiaocn.github.io/tags/ROS/"}]},{"title":"初级 ROS 通信编程流程","slug":"ros-communication","date":"2019-12-02T12:25:50.000Z","updated":"2020-01-18T06:05:33.909Z","comments":true,"path":"2019/12/02/ros-communication/","link":"","permalink":"https://zhangxiaocn.github.io/2019/12/02/ros-%C2%96%C2%96communication/","excerpt":"","text":"笔记整理记录自：https://www.bilibili.com/video/av69417218 1、话题编程 1.1、新建工作空间 新建 catkin_ws 文件：mkdir -p catkin_ws/src 进入 catkin_ws 目录：cd catkin_ws 初始化：catkin_make 进入 src 文件：cd src 创建用于通信的 package：catkin_create_pkg learning_test1 std_msgs rospy roscpp 编译一下：catkin_make 添加 source：echo &quot;source ~/catkin_ws/devel/setup.zsh &quot; &gt;&gt; ~/.zshrc 返回根目录：cd 查看 source 是否添加：gedit .zshrc 或者 vi .zshrc 1.2、创建编程文件 找到刚才的工作空间：cd ~/catkin_ws/src/learning_test1/src 新建 talker.cpp 文件：gedit talker.cpp 保存如下代码： c++123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * 该例程将发布chatter话题，消息类型String */#include &lt;sstream&gt;#include \"ros/ros.h\"#include \"std_msgs/String.h\"int main(int argc, char **argv)&#123; // ROS节点初始化 ros::init(argc, argv, \"talker\"); // 创建节点句柄 ros::NodeHandle n; // 创建一个Publisher，发布名为chatter的topic，消息类型为std_msgs::String ros::Publisher chatter_pub = n.advertise&lt;std_msgs::String&gt;(\"chatter\", 1000); // 设置循环的频率 ros::Rate loop_rate(10); int count = 0; while (ros::ok()) &#123; // 初始化std_msgs::String类型的消息 std_msgs::String msg; std::stringstream ss; ss &lt;&lt; \"hello world \" &lt;&lt; count; msg.data = ss.str(); // 发布消息 ROS_INFO(\"%s\", msg.data.c_str()); chatter_pub.publish(msg); // 循环等待回调函数 ros::spinOnce(); // 按照循环频率延时 loop_rate.sleep(); ++count; &#125; return 0;&#125; 新建 listener.cpp 文件：gedit listener.cpp 保存如下代码： c++123456789101112131415161718192021222324252627282930/** * 该例程将订阅chatter话题，消息类型String */#include \"ros/ros.h\"#include \"std_msgs/String.h\"// 接收到订阅的消息后，会进入消息回调函数void chatterCallback(const std_msgs::String::ConstPtr&amp; msg)&#123; // 将接收到的消息打印出来 ROS_INFO(\"I heard: [%s]\", msg-&gt;data.c_str());&#125;int main(int argc, char **argv)&#123; // 初始化ROS节点 ros::init(argc, argv, \"listener\"); // 创建节点句柄 ros::NodeHandle n; // 创建一个Subscriber，订阅名为chatter的topic，注册回调函数chatterCallback ros::Subscriber sub = n.subscribe(\"chatter\", 1000, chatterCallback); // 循环等待回调函数 ros::spin(); return 0;&#125; 1.3、配置 找到刚才的工作空间：cd ~/catkin_ws/src/learning_test1/ 编辑 CMakeLists.txt 文件：gedit CMakeLists.txt 保存如下代码： Code1234add_executable(talker src/talker.cpp)add_executable(listener src/listener.cpp)target_link_libraries(talker $&#123;catkin_LIBRARIES&#125;)target_link_libraries(listener $&#123;catkin_LIBRARIES&#125;) 返回主目录：cd ~/catkin_ws/ 编译一下：catkin_make 1.4、运行 新建终端，启动 ros：roscore 新建终端，启动 listener：rosrun learning_test1 listener 新建终端，启动 talker：rosrun learning_test1 talker 即可看到效果 *1.5、自定义话题消息（添加 msg） 找到刚才的工作空间：cd ~/catkin_ws/src/learning_test1/ 新建一个 msg 文件夹：mkdir msg 进入 msg 文件夹：cd msg 新建一个名为 Person.msg 的文件：gedit Person.msg 保存如下测试代码： c++1234567string nameuint8 sexuint8 ageuint8 unknown = 0uint8 male = 1uint8 female = 2 退回上一个文件夹：cd .. 修改 package.xml 文件，添加功能包依赖：gedit package.xml 添加如下代码： xml12&lt;build_depend&gt;message_generation&lt;/build_depend&gt;&lt;exec_depend&gt;message_runtime&lt;/exec_depend&gt; 修改 CMakeLists.txt 文件，添加功能包依赖：gedit CMakeLists.txt 添加如下代码（注意添加的位置，放错位置会报错）： Code1234find_package(..... message_generation)catkin_package(CATKIN_DEPENDS roscpp rospy std_msgs message_runtime)add_message_files(FILES Person.msg)generate_messages(DEPENDENCIES std_msgs) 返回主目录：cd ~/catkin_ws/ 编译一下：catkin_make 可以用 rosmsg show Person 命令查看 Person.msg 的内容 2、服务编程（加法例程） 2.1、新建工作空间 方法和话题编程第一步一样，注意换一个 package 名称，例如：catkin_create_pkg learning_test2 std_msgs rospy roscpp 2.2、创建 srv 文件 找到刚才的工作空间：cd ~/catkin_ws/src/learning_test2/ 新建 srv 文件夹：mkdir srv 新建文件：gedit AddTwoInts.srv 保存如下代码： c++1234int64 a // 服务的请求数据int64 b---int64 sum // 服务的应答数据 2.3、配置 找到刚才的工作空间：cd ~/catkin_ws/src/learning_test2/ 编辑 package.xml 文件：gedit package.xml 保存如下代码： xml12&lt;build_depend&gt;message_generation&lt;/build_depend&gt;&lt;exec_depend&gt;message_runtime&lt;/exec_depend&gt; 编辑 CMakeLists.txt 文件：gedit CMakeLists.txt 保存如下代码 c++123find_package(.... message_generation)catkin_package(.... message_runtime)add_service_files(FILES AddTwoInts.srv) 返回主目录：cd ~/catkin_ws/ 编译一下：catkin_make 2.4、添加用户程序 找到刚才的工作空间：cd ~/catkin_ws/src/learning_test2/src 新建 server.cpp 文件：gedit server.cpp 保存如下代码： c++123456789101112131415161718192021222324252627282930313233343536/** * AddTwoInts Server */#include \"ros/ros.h\"#include \"learning_test2/AddTwoInts.h\"// service回调函数，输入参数req，输出参数resbool add(learning_test2::AddTwoInts::Request &amp;req, learning_test2::AddTwoInts::Response &amp;res)&#123; // 将输入参数中的请求数据相加，结果放到应答变量中 res.sum = req.a + req.b; ROS_INFO(\"request: x=%ld, y=%ld\", (long int)req.a, (long int)req.b); ROS_INFO(\"sending back response: [%ld]\", (long int)res.sum); return true;&#125;int main(int argc, char **argv)&#123; // ROS节点初始化 ros::init(argc, argv, \"add_two_ints_server\"); // 创建节点句柄 ros::NodeHandle n; // 创建一个名为add_two_ints的server，注册回调函数add() ros::ServiceServer service = n.advertiseService(\"add_two_ints\", add); // 循环等待回调函数 ROS_INFO(\"Ready to add two ints.\"); ros::spin(); return 0;&#125; 新建 client.cpp 文件：gedit client.cpp 保存如下代码： c++1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * AddTwoInts Client */#include &lt;cstdlib&gt;#include \"ros/ros.h\"#include \"learning_test2/AddTwoInts.h\"int main(int argc, char **argv)&#123; // ROS节点初始化 ros::init(argc, argv, \"add_two_ints_client\"); // 从终端命令行获取两个加数 if (argc != 3) &#123; ROS_INFO(\"usage: add_two_ints_client X Y\"); return 1; &#125; // 创建节点句柄 ros::NodeHandle n; // 创建一个client，请求add_two_int service，service消息类型是learning_communication::AddTwoInts ros::ServiceClient client = n.serviceClient&lt;learning_test2::AddTwoInts&gt;(\"add_two_ints\"); // 创建learning_communication::AddTwoInts类型的service消息 learning_test2::AddTwoInts srv; srv.request.a = atoll(argv[1]); srv.request.b = atoll(argv[2]); // 发布service请求，等待加法运算的应答结果 if (client.call(srv)) &#123; ROS_INFO(\"Sum: %ld\", (long int)srv.response.sum); &#125; else &#123; ROS_ERROR(\"Failed to call service add_two_ints\"); return 1; &#125; return 0;&#125; 2.5、再配置 找到刚才的工作空间：cd ~/catkin_ws/src/learning_test2/ 编辑 CMakeLists.txt 文件：gedit CMakeLists.txt 保存如下代码： Code1234567add_executable(server src/server.cpp)target_link_libraries(server $&#123;catkin_LIBRARIES&#125;)add_dependencies(server $&#123;PROJECT_NAME&#125;_gencpp)add_executable(client src/client.cpp)target_link_libraries(client $&#123;catkin_LIBRARIES&#125;)add_dependencies(client $&#123;PROJECT_NAME&#125;_gencpp) 返回主目录：cd ~/catkin_ws/ 编译一下：catkin_make 2.6、运行 新建终端，启动 ros：roscore 新建终端，启动 server：rosrun learning_test2 server 新建终端，启动 client：rosrun learning_test1 client 3 5 即可看到效果（3+5=8） 3、动作编程（洗盘子例程） 3.1、新建工作空间 方法和话题编程第一步一样，注意换一个 package 名称，例如：catkin_create_pkg learning_tes3 std_msgs rospy roscpp 3.2、创建 action 文件 找到刚才的工作空间：cd ~/catkin_ws/src/learning_test3/ 新建 action 文件夹：mkdir action 新建文件：gedit DoDishes.action 保存如下代码： Code12345678# Define the goaluint32 dishwasher_id # Specify which dishwasher we want to use---# Define the resultuint32 total_dishes_cleaned---# Define a feedback messagefloat32 percent_complete 3.3、配置 找到刚才的工作空间：cd ~/catkin_ws/src/learning_test3/ 编辑 package.xml 文件：gedit package.xml 保存如下代码： xml1234&lt;build_depend&gt;actionlib&lt;/build_depend&gt;&lt;build_depend&gt;actionlib_msgs&lt;/build_depend&gt;&lt;exec_depend&gt;actionlib&lt;/exec_depend&gt;&lt;exec_depend&gt;actionlib_msgs&lt;/exec_depend&gt; 编辑 CMakeLists.txt 文件：gedit CMakeLists.txt 保存如下代码 c++123find_package(catkin REQUIRED actionlib_msgs actionlib)add_action_files(DIRECTORY action FILES DoDishes.action)generate_messages(DEPENDENCIES actionlib_msgs) 返回主目录：cd ~/catkin_ws/ 编译一下：catkin_make 3.4、添加用户程序 找到刚才的工作空间：cd ~/catkin_ws/src/learning_test3/src 新建 DoDishes_server.cpp 文件：gedit DoDishes_server.cpp 保存如下代码： c++123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;ros/ros.h&gt;#include &lt;actionlib/server/simple_action_server.h&gt;#include \"learning_test3/DoDishesAction.h\"typedef actionlib::SimpleActionServer&lt;learning_test3::DoDishesAction&gt; Server;// 收到action的goal后调用该回调函数void execute(const learning_test3::DoDishesGoalConstPtr&amp; goal, Server* as)&#123; ros::Rate r(1); learning_test3::DoDishesFeedback feedback; ROS_INFO(\"Dishwasher %d is working.\", goal-&gt;dishwasher_id); // 假设洗盘子的进度，并且按照1hz的频率发布进度feedback for(int i=1; i&lt;=10; i++) &#123; feedback.percent_complete = i * 10; as-&gt;publishFeedback(feedback); r.sleep(); &#125; // 当action完成后，向客户端返回结果 ROS_INFO(\"Dishwasher %d finish working.\", goal-&gt;dishwasher_id); as-&gt;setSucceeded();&#125;int main(int argc, char** argv)&#123; ros::init(argc, argv, \"do_dishes_server\"); ros::NodeHandle n; // 定义一个服务器 Server server(n, \"do_dishes\", boost::bind(&amp;execute, _1, &amp;server), false); // 服务器开始运行 server.start(); ros::spin(); return 0;&#125; 新建 DoDishes_client.cpp 文件：gedit DoDishes_client.cpp 保存如下代码： c++123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;actionlib/client/simple_action_client.h&gt;#include \"learning_test3/DoDishesAction.h\"typedef actionlib::SimpleActionClient&lt;learning_test3::DoDishesAction&gt; Client;// 当action完成后会调用该回调函数一次void doneCb(const actionlib::SimpleClientGoalState&amp; state, const learning_test3::DoDishesResultConstPtr&amp; result)&#123; ROS_INFO(\"Yay! The dishes are now clean\"); ros::shutdown();&#125;// 当action激活后会调用该回调函数一次void activeCb()&#123; ROS_INFO(\"Goal just went active\");&#125;// 收到feedback后调用该回调函数void feedbackCb(const learning_test3::DoDishesFeedbackConstPtr&amp; feedback)&#123; ROS_INFO(\" percent_complete : %f \", feedback-&gt;percent_complete);&#125;int main(int argc, char** argv)&#123; ros::init(argc, argv, \"do_dishes_client\"); // 定义一个客户端 Client client(\"do_dishes\", true); // 等待服务器端 ROS_INFO(\"Waiting for action server to start.\"); client.waitForServer(); ROS_INFO(\"Action server started, sending goal.\"); // 创建一个action的goal learning_test3::DoDishesGoal goal; goal.dishwasher_id = 1; // 发送action的goal给服务器端，并且设置回调函数 client.sendGoal(goal, &amp;doneCb, &amp;activeCb, &amp;feedbackCb); ros::spin(); return 0;&#125; 3.5、再配置 找到刚才的工作空间：cd ~/catkin_ws/src/learning_test3/ 编辑 CMakeLists.txt 文件：gedit CMakeLists.txt 保存如下代码： Code1234567add_executable(DoDishes_client src/DoDishes_client.cpp)target_link_libraries(DoDishes_client $&#123;catkin_LIBRARIES&#125;)add_dependencies(DoDishes_client $&#123;$&#123;PROJECT_NAME&#125;_EXPORTED_TARGETS&#125;)add_executable(DoDishes_server src/DoDishes_server.cpp)target_link_libraries(DoDishes_server $&#123;catkin_LIBRARIES&#125;)add_dependencies(DoDishes_server $&#123;$&#123;PROJECT_NAME&#125;_EXPORTED_TARGETS&#125;) 返回主目录：cd ~/catkin_ws/ 编译一下：catkin_make 3.6、运行 新建终端，启动 ros：roscore 新建终端，启动 server：rosrun learning_test3 DoDishes_client 新建终端，启动 client：rosrun learning_test1 DoDishes_server 即可看到效果（洗盘子进度）","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://zhangxiaocn.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"ROS","slug":"ROS","permalink":"https://zhangxiaocn.github.io/tags/ROS/"}]},{"title":"ROS Melodic 小海龟操控实例","slug":"ros-turtle","date":"2019-12-02T12:20:10.000Z","updated":"2020-02-03T05:12:48.012Z","comments":true,"path":"2019/12/02/ros-turtle/","link":"","permalink":"https://zhangxiaocn.github.io/2019/12/02/ros-turtle/","excerpt":"","text":"执行新的命令操作时，均需要启动一个新的终端然后输入命令。 基础操作： 启动 ROS Master：roscore 启动小海龟仿真器：rosrun turtlesim turtlesim_node 启动小海龟键盘控制节点：rosrun turtlesim turtle_teleop_key 此时按键盘上的方向键即可操控小海龟运行 其他操作： 提前说明：有小伙伴曾反馈指令有问题，输入后会报错。经查实，是因为不同行的问题，如果指令都在同一行，则会出现问题。所以不要把不同行的代码在同一行输入！ 新生一只小海龟： Code1234rosservice call /spawn &quot;x: 5.0y: 5.0theta: 0.0name: &apos;turtle2&apos;&quot; 让第一只小海龟绕圈跑： 代码中的 x,y,z 为坐标及角度信息，按照意愿自行修改即可。 -r 10 表示让命令以 10Hz 的频率控制小海龟运行，可以自行修改或者删除该指令。 Code12345678rostopic pub -r 10 /turtle1/cmd_vel geometry_msgs/Twist &quot;linear: x: 1.0 y: 0.0 z: 0.0angular: x: 0.0 y: 0.0 z: 1.0&quot; 不喜欢换行输入的小伙伴，可以输入如下简化指令：rostopic pub -r 10 /turtle1/cmd_vel geometry_msgs/Twist -- '[1.0, 0.0, 0.0]' '[0.0, 0.0, 1.0]' 同理，让第二只小海龟绕圈跑： Code12345678rostopic pub -r 10 /turtle2/cmd_vel geometry_msgs/Twist &quot;linear: x: 1.0 y: 0.0 z: 0.0angular: x: 0.0 y: 0.0 z: 1.0&quot; 一只小海龟追赶另外一只小海龟实例： 安装小海龟坐标变换功能包：sudo apt install ros-melodic-turtle-tf 运行功能包：roslaunch turtle_tf turtle_tf_demo.launch 启动小海龟键盘控制节点：rosrun turtlesim turtle_teleop_key 此时按键盘上的方向键即可操控第一只小海龟运行，第二只小海龟会自动跟踪第一只小海龟","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://zhangxiaocn.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"ROS","slug":"ROS","permalink":"https://zhangxiaocn.github.io/tags/ROS/"}]},{"title":"Ubuntu18.04LTS 美化（仿Mac）","slug":"ubuntu-beautify","date":"2019-11-22T11:16:32.000Z","updated":"2020-01-09T12:47:22.272Z","comments":true,"path":"2019/11/22/ubuntu-beautify/","link":"","permalink":"https://zhangxiaocn.github.io/2019/11/22/ubuntu-beautify/","excerpt":"","text":"如下为本人美化后的界面： 1、安装美化软件 安装美化软件 gnome-tweak-tool：sudo apt install gnome-tweak-tool 安装完成后，找到名为 优化 的软件并打开 选择 窗口 选项，将 放置 选项改为 左，其他的根据喜好自定义 安装相应的插件：sudo apt-get install gnome-shell-extensions 安装完成后，重启系统 打开 优化，找到 扩展 选项，打开 User themes 关闭软件 2、安装 Mac 主题/图标 打开 Mac 主题网址：https://www.gnome-look.org/p/1275087/ 选择 Files 选项，将名为 Mojave-dark.tar.xz 和 Mojave-light.tar.xz 下载下来 解压下载完成的主题压缩包 在解压的主题所在目录，打开终端 将主题放入系统主题目录：sudo cp -r Mojave-light/ /usr/share/themes/、sudo cp -r Mojave-dark/ /usr/share/themes/ 打开 优化 软件，选择 外观 选项，找到 主题，将主题改为 Mac 主题 找到 shell，改为 Mac 主题 打开 Mac 图标网址：https://www.opendesktop.org/s/Gnome/p/1102582/ 选择 Files 选项，将名为 Cupertino.tar.xz 的文件下载下来 解压下载完成的图标压缩包 在解压的主题所在目录，打开终端 将主题放入系统图标目录：sudo cp -r Cupertino-Mojave/ /usr/share/icons/ 打开 优化 软件，选择 外观 选项，找到 图标，将图标改为 Mac 图标即可 3、安装相应扩展 打开 Ubuntu 应用商店，安装 Dash to Dock 用火狐浏览器打开：https://extensions.gnome.org/ 点击提示栏里的 Click here to install browser extension 选项，允许安装 终端输入：sudo apt-get install chrome-gnome-shell 安装浏览器插件 刷新浏览器界面 搜索 Dash to Dock 并安装（Dock 栏扩展） 搜索 Coverflow Alt-Tab 并安装（切换窗口扩展） 搜索 Open Weather 并安装（天气扩展） 搜索 Screenshot Tool 并安装（截图扩展） 搜索 Simple net speed 并安装（网速指示扩展） 打开 优化，找到 扩展，点击每个扩展后面的齿轮图标，可以对下载的扩展进行相应设置 其他的插件根据需要下载","categories":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://zhangxiaocn.github.io/categories/Ubuntu/"}],"tags":[{"name":"美化","slug":"美化","permalink":"https://zhangxiaocn.github.io/tags/%E7%BE%8E%E5%8C%96/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://zhangxiaocn.github.io/tags/Ubuntu/"}]},{"title":"安装 Ubuntu18.04 双系统笔记","slug":"win10-ubuntu","date":"2019-11-22T11:02:38.000Z","updated":"2020-01-09T12:38:50.590Z","comments":true,"path":"2019/11/22/win10-ubuntu/","link":"","permalink":"https://zhangxiaocn.github.io/2019/11/22/win10-ubuntu/","excerpt":"","text":"1、安装双系统 1.1、制作 Ubuntu 系统安装 U盘 下载 Ubuntu 安装镜像，建议下载 LTS 长期支持版：https://ubuntu.com/download/desktop 使用 ultraiso，或者使用其他镜像制作软件，将 Ubuntu 系统拷至 U 盘里，具体方法百度搜索一堆。 1.2、前期磁盘准备 在 Win10 中，鼠标右键选择 计算机 --&gt; 管理 --&gt; 磁盘管理 选择你需要安装 Ubuntu 的磁盘，右键选择 压缩卷，压缩一个你需要的空间大小（建议至少 60G，不要分配盘符） 打开 系统设置 --&gt; 系统 --&gt; 电源和睡眠 --&gt; 其他电源设置 --&gt; 选择电源按钮的功能 --&gt; 更改当前不可用的设置 --&gt; 关闭启用快速启动的选项（如果上述步骤没找到，可以百度搜索 Win10 关闭快速启动方法） 1.3、前期 BIOS 准备 重启电脑，开机后立刻按 F2 进入 BIOS（如果不是 F2 键，请自行搜索你的电脑的 BIOS 进入按键） 找到 Security 选项，将 Security Boot 选项关闭 找到 Fast Boot 选项并关闭 1.4、安装 Ubuntu 关闭电脑，插上刚才制作好的 U 盘 启动电脑，按 F12，选择 U 盘启动 接着会出现 Ubuntu 界面，选择 Install Ubuntu（接下来安装过程不要拔掉 U 盘） 前几步自定义就行，整个过程不要联网，如果出现 安装更新和第三方软件 选项，取消勾选 接着最重要的一步，出现安装类型界面时，选择 其他选项，不要选择 安装 Ubuntu，与 Windows Boot Manager 共存 这个选项，有点坑 1.5、安装类型配置 点击你分配的磁盘，选择加号，进行如下配置： SWAP 交换空间（虚拟内存） 大小：与电脑内存一致 新分区的类型：主分区 新分区的位置：空间起始位置 用于：交换空间 EFI 系统分区（系统引导文件位置） 大小：建议最少 256MB 新分区的类型：逻辑分区 新分区的位置：空间起始位置 用于：EFI 系统分区 /home（个人文件夹） 大小：建议最少 8G，存放个人文件的地方 新分区的类型：逻辑分区 新分区的位置：空间起始位置 用于：EXT4 日志文件系统 挂载点：/home /（其他目录） 大小：建议 8G 左右即可 新分区的类型：逻辑分区 新分区的位置：空间起始位置 用于：EXT4 日志文件系统 挂载点：/ /usr（软件安装位置） 大小：安装软件的位置，尽量给大一点，将剩下的所有空间都给它就好 新分区的类型：逻辑分区 新分区的位置：空间起始位置 用于：EXT4 日志文件系统 挂载点：/usr 找到你刚才新建的类型为 efi 的设备，在 安装启动引导器的设备 选项中，选中它 点击 现在安装 ，点击 继续 后面的步骤完全自定义即可，没有什么坑了 2、配置及相关问题解决方案 2.1、安装搜狗输入法及相关问题 安装 Fcitx 框架：sudo apt install fcitx 安装完成后，进入 语言支持 设置，将 键盘输入法系统 改为 fcitx 重启计算机 下载搜狗输入法 .deb 包并安装 进入 fcitx 配置，将搜狗输入法添加进去，为了避免中文乱码问题，输入法选项里只保留如下三个（包括顺序）： 键盘 - 汉语 搜狗拼音 键盘 - 英语(美国) 设置完成后，点击上方的 全局配置，将 启用输入法间切换 选项关闭 通过 Shift 键即可切换中英文 2.2、无法识别 exfat 格式 U 盘 终端输入：sudo apt-get install exfat-utils 安装即可 2.3、与 Windows 时间冲突错误问题 使用 ntpdate 校准时间： 首先安装 ntpdate：sudo apt-get install ntpdate 校准时间：sudo ntpdate time.windows.com 再将时间更新到硬件上，以免 Windows 的时间也是不对的：sudo hwclock --localtime --systohc 2.4、关闭 Ubuntu 错误报告 临时关闭（重启系统后失效）：sudo service apport stop 永久关闭： 输入：sudo gedit /etc/default/apport 修改 enabled=0，重启生效 永久性的移除错误报告功能：sudo apt-get purge apport 2.5、更换字体 如下为安装文泉驿米黑字体方法 安装文泉驿微米黑：sudo apt-get install ttf-wqy-microhei #文泉驿-微米黑 安装文泉驿正黑：sudo apt-get install ttf-wqy-zenhei #文泉驿-正黑 安装文泉驿点阵宋体：sudo apt-get install xfonts-wqy #文泉驿-点阵宋体 2.6、Grub 管理 下载 grub-customizer 进行管理 终端输入： Code123sudo add-apt-repository ppa:danielrichter2007/grub-customizersudo apt-get updatesudo apt-get install grub-customizer 打开 grub-customizer 软件进行相应配置即可 2.7、Dock 优化 启用 Minimize on Click： Code1gsettings set org.gnome.shell.extensions.dash-to-dock click-action &apos;minimize&apos; 完成后，点击已打开的软件 dock 图标即可把软件缩小至 dock 2.8、更换 GDM 登录背景图片 打开 ubuntu.css 文件：sudo gedit /usr/share/gnome-shell/theme/ubuntu.css 找到关键字 lockDialogGroup： css1234#lockDialogGroup &#123; background: #2c001e url(resource:///org/gnome/shell/theme/noise-texture.png); background-repeat: repeat;&#125; 修改图片路径 background 后的 url 即可，例如： css123456#lockDialogGroup &#123; background: #2c001e url(file:///home/zzzx/image/image.jpg); background-repeat: no-repeat; background-size: cover; background-position: center;&#125; 建议修改 background-repeat 为 no-repeat 添加 background-size 以及 background-position 项","categories":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://zhangxiaocn.github.io/categories/Ubuntu/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://zhangxiaocn.github.io/tags/Ubuntu/"},{"name":"双系统","slug":"双系统","permalink":"https://zhangxiaocn.github.io/tags/%E5%8F%8C%E7%B3%BB%E7%BB%9F/"}]},{"title":"博客园美化","slug":"cnblogs-beautify","date":"2019-11-06T13:04:40.000Z","updated":"2020-01-08T15:10:25.868Z","comments":true,"path":"2019/11/06/cnblogs-beautify/","link":"","permalink":"https://zhangxiaocn.github.io/2019/11/06/cnblogs-beautify/","excerpt":"","text":"以下部分教程来源于互联网，仅作为本人学习所用。 1、每日一言 在侧边栏加入以下 css 代码即可： 12345678910111213141516&lt;meta charset=\"utf-8\"/&gt; &lt;h2&gt;&lt;B&gt;一言（ヒトコト）&lt;/B&gt;&lt;/h2&gt; &lt;div class=\"daily a pome\"&gt; &lt;div class=\"daily pome\" id=\"qwq\"&gt;&lt;/div&gt; &lt;script&gt; var st=[\"&lt;center&gt;没有神的光环，我们生而平凡 &lt;br&gt; &lt;center&gt;这就是你不拿rank1得理由？&lt;br&gt;\", \"&lt;center&gt;我遇见你，我记住你&lt;br&gt;&lt;center&gt;这座城市天生适合恋爱，&lt;br&gt;&lt;center&gt;你的灵魂天生适合我&lt;br&gt;\", \"&lt;center&gt;你知道&lt;br&gt;&lt;center&gt;Nice to meet you&lt;br&gt;&lt;center&gt;是什么意思么？&lt;br&gt;&lt;center&gt;很高兴见到你呗&lt;br&gt;&lt;center&gt;不啊，“有生之年，幸得相逢。”&lt;br&gt;\", \"&lt;center&gt;前半生无你&lt;br&gt;&lt;center&gt;余生请指教.&lt;br&gt;\", \"&lt;center&gt;你好，冒昧打搅了&lt;br&gt;&lt;center&gt;我今天也特别喜欢你.&lt;br&gt;\", \"&lt;center&gt;it takes sonebody an hour to like someonoe,&lt;br&gt;&lt;center&gt;and a day to like someone,&lt;br&gt;&lt;center&gt;but it takes a life time to forget someone.&lt;br&gt;\", \"&lt;center&gt;you have only one life and one chance to do all the things you want to do.&lt;br&gt;\", \"&lt;center&gt;你就像桌上那份时事报,&lt;br&gt;&lt;center&gt;当时读新鲜，以后读怀念&lt;br&gt;&lt;center&gt;悲欢越来越远,&lt;br&gt;&lt;center&gt;可还是会小心翼翼地折好，安放&lt;br&gt;\", \"&lt;center&gt;你特别好，我喜欢你&lt;br&gt;\", \"&lt;center&gt;我终不能改变那个开始，&lt;br&gt;&lt;center&gt;何不忘了那个结局呢？&lt;br&gt;\", \"&lt;center&gt;it takes only a smile to make a darkday seem bright&lt;br&gt;\", \"&lt;center&gt;无论在哪里遇上你，&lt;br&gt;&lt;center&gt;我都会喜欢你&lt;br&gt;\", \"&lt;center&gt; 你若盛开，清风自来&lt;br&gt;\", \"&lt;center&gt;用我一生,&lt;br&gt;&lt;center&gt;换你十年天真。&lt;br&gt;&lt;center&gt;忘了我吧，&lt;br&gt;&lt;center&gt;吴邪。&lt;br&gt;\", \"&lt;center&gt;太想摘取星星得人，&lt;br&gt;&lt;center&gt;往往忽视了脚下得鲜花。&lt;br&gt;\", \"&lt;center&gt; 无论发生什么，&lt;br&gt;&lt;center&gt;希望你都不要后悔与我得相识。&lt;br&gt;\", \"&lt;center&gt; 生生生生暗生始，&lt;br&gt;&lt;center&gt;死死死死冥死终。&lt;br&gt;\", \"&lt;center&gt; 未来不是被给予的，&lt;br&gt;&lt;center&gt;而是自己争取的。 &lt;br&gt;\", \"&lt;center&gt; あたいってば最強ね！ &lt;br&gt;\", \"&lt;center&gt; 十步杀一人，&lt;br&gt;&lt;center&gt; 千里不留行。&lt;br&gt;\", \"&lt;center&gt; 当一切都消失得时候&lt;br&gt;&lt;center&gt; 你就会明白生命有何价值&lt;br&gt;\", \"&lt;center&gt; 不是他，变成他&lt;br&gt;\", \"&lt;center&gt; 也许我们都没有长大，&lt;br&gt;&lt;center&gt; 只是世界变小了。&lt;br&gt;\", \"&lt;center&gt; Time waits for no one.&lt;br&gt;\", \"&lt;center&gt; 和绝望，&lt;br&gt;&lt;center&gt; 和睦相处&lt;br&gt;\"]; var num; num=Math.floor((Math.random()*25)); document.write(st[num]); var cli; &lt;/script&gt; &lt;div style=\"font-size: 1em; text-align: center; line-height: 1.5em; display: none; \" id=\"qwq\"&gt;&lt;/div&gt; &lt;div style=\"text-align: right; margin-top: 15px; font-size: 0.9em; color: #666; display: none; \" id=\"qwq\"&gt;&lt;/div&gt; &lt;/div&gt; 或者： 12345678910111213141516&lt;meta charset=\"utf-8\"/&gt; &lt;h2&gt;&lt;B&gt;一言（ヒトコト）&lt;/B&gt;&lt;/h2&gt; &lt;div class=\"daily a pome\"&gt; &lt;div class=\"daily pome\" id=\"qwq\"&gt;&lt;/div&gt; &lt;script&gt; var st=[\"&lt;center&gt;你不是一个人&lt;br&gt;&lt;center&gt; ——lmh&lt;br&gt;\", \"&lt;center&gt;这不是bzoj原题吗&lt;br&gt;&lt;center&gt; ——hjw&lt;br&gt;\", \"&lt;center&gt;我去骗钥匙啦~&lt;br&gt;&lt;center&gt; ——yxy&lt;br&gt;\", \"&lt;center&gt;你无聊吗，快去刷题。&lt;br&gt;&lt;center&gt; ——lmh&lt;br&gt;\", \"&lt;center&gt;loj.ac&lt;br&gt;&lt;center&gt; ——lmh&lt;br&gt;\", \"&lt;center&gt;想和zn谈恋爱&lt;br&gt;&lt;center&gt; ——lmh&lt;br&gt;\", \"&lt;center&gt;zc大人我错了！&lt;br&gt;&lt;center&gt; ——wjd&lt;br&gt;\", \"&lt;center&gt;zn：有没有说出题人谁啊&lt;br&gt;&lt;center&gt;yxy：好像是lxq？？&lt;br&gt;&lt;center&gt;zn：暴打出题人&lt;center&gt;yxy：老师！！！&lt;br&gt;\", \"&lt;center&gt;学习线性解决a+b问题&lt;br&gt;&lt;center&gt; ——zn&lt;br&gt;\", \"&lt;center&gt;代码已经给出，&lt;br&gt;&lt;center&gt; 读者自证不难。&lt;br&gt;&lt;center&gt; ——lrj\", \"&lt;center&gt;啊&lt;br&gt;&lt;center&gt;我要女装！&lt;br&gt;&lt;center&gt; ——zzx&lt;br&gt;\", \"&lt;center&gt;辛苦了~&lt;br&gt;&lt;center&gt; ——lmh&lt;br&gt;\", \"&lt;center&gt;棒！&lt;br&gt;&lt;center&gt; ——lmh&lt;br&gt;\", \"&lt;center&gt;学OI后悔三年&lt;br&gt;&lt;center&gt;不学OI后悔一辈子/呲牙&lt;br&gt;&lt;center&gt; ——zn&lt;br&gt;\", \"&lt;center&gt;又把1e3+7写成1e4+7了……&lt;br&gt;&lt;center&gt;干脆叫万柒吧。。&lt;br&gt;&lt;center&gt; ——yxy&lt;br&gt;\", \"&lt;center&gt;即得易见平凡，由上自证显然，留作习题答案略，读者自证不难。&lt;br&gt;&lt;center&gt;反之亦然同理，推论自然成立，略去过程Q.E.D，由上可知证毕。&lt;br&gt;&lt;center&gt; ——lca\", \"&lt;center&gt;我要让zn提头来见我&lt;br&gt;&lt;center&gt; ——lmh&lt;br&gt;\", \"&lt;center&gt;这年头 expert 很难么？&lt;br&gt;&lt;center&gt; ——zn&lt;br&gt;\", \"&lt;center&gt;成为很厉害很厉害的人，最重要的，就是要热血，永远也不要让你的血凉下去。&lt;br&gt;&lt;center&gt; ——hzwer\", \"&lt;center&gt;高中的 OI 刚刚开始，希望不要那么快就凋零。兔纸的时间已经不多，请把自己选择的路，好好走下去。&lt;br&gt;&lt;center&gt; ——Bunnycxk\", \"&lt;center&gt;Who laughs last laughs best!&lt;br&gt;&lt;center&gt; ——Emma\", \"&lt;center&gt;别哭，眼泪会冻住的。&lt;br&gt;&lt;center&gt; ——那年那兔那些事儿\" ]; var num; num=Math.floor((Math.random()*22)); document.write(st[num]); var cli; &lt;/script&gt; &lt;div style=\"font-size: 1em; text-align: center; line-height: 1.5em; display: none; \" id=\"qwq\"&gt;&lt;/div&gt; &lt;div style=\"text-align: right; margin-top: 15px; font-size: 0.9em; color: #666; display: none; \" id=\"qwq\"&gt;&lt;/div&gt; &lt;/div&gt; 2、鼠标点击特效 在页脚 html 代码处加入以下 css 代码即可： 123456789101112131415161718192021222324252627282930&lt;script type=\"text/javascript\"&gt;/* 鼠标特效 */var a_idx = 0;jQuery(document).ready(function($) &#123; $(\"body\").click(function(e) &#123; var a = new Array(\"❤富强❤\",\"❤民主❤\",\"❤文明❤\",\"❤和谐❤\",\"❤自由❤\",\"❤平等❤\",\"❤公正❤\",\"❤法治❤\",\"❤爱国❤\",\"❤敬业❤\",\"❤诚信❤\",\"❤友善❤\"); var $i = $(\"&lt;span&gt;&lt;/span&gt;\").text(a[a_idx]); a_idx = (a_idx + 1) % a.length; var x = e.pageX, y = e.pageY; $i.css(&#123; \"z-index\": 999999999999999999999999999999999999999999999999999999999999999999999, \"top\": y - 20, \"left\": x, \"position\": \"absolute\", \"font-weight\": \"bold\", \"color\": \"rgb(\"+~~(255*Math.random())+\",\"+~~(255*Math.random())+\",\"+~~(255*Math.random())+\")\" &#125;); $(\"body\").append($i); $i.animate(&#123; \"top\": y - 180, \"opacity\": 0 &#125;, 1500, function() &#123; $i.remove(); &#125;); &#125;);&#125;);&lt;/script&gt; 可以修改第六行中代码中双引号内的字。 3、改变博客图标 在页首 html 代码处加入以下代码即可 123456789&lt;div style = \"display:none;\" &gt;把博客园图标替换成自己的图标 &lt;/div&gt;&lt;script type=\"text/javascript\" language=\"javascript\"&gt; //Setting ico for cnblogs var linkObject = document.createElement('link'); linkObject.rel = \"shortcut icon\"; linkObject.href = \"https://i.loli.net/2018/09/24/5ba8bcd213e78.jpg\"; document.getElementsByTagName(\"head\")[0].appendChild(linkObject);&lt;/script&gt;&lt;div style = \"display:none;\" &gt;把博客园图标替换成自己的图标end &lt;/div&gt; 将第六行的链接地址换成自己的即可。 4、改变博客标题 在离开当前博客的标签页以及点进去的时候会出现，2s 之后会消失，并不会影响阅读。 需要在页脚 html 中加入以下代码： 修改方法有注释在代码中 1234567891011121314151617&lt;div style = \"display:none;\" &gt; 浏览器标题切换 &lt;/div&gt;&lt;script&gt; var OriginTitile = document.title; // 保存之前页面标题 var titleTime; document.addEventListener('visibilitychange', function()&#123; if (document.hidden)&#123; document.title ='你不要我了么？qwq'; // 切出文字 clearTimeout(titleTime); &#125;else&#123; document.title = '欢迎回来～'; // 切入文字 titleTime = setTimeout(function() &#123; document.title = OriginTitile; &#125;, 1000); // 2秒后恢复原标题 &#125; &#125;); &lt;/script&gt;&lt;div style = \"display:none;\" &gt; 浏览器标题切换end &lt;/div&gt; 5、背景中的动态线条 放入侧边栏即可： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899&lt;div style = \"display:none;\"&gt;动态线条&lt;/div&gt;&lt;script&gt;!function()&#123;function n(n,e,t)&#123;return n.getAttribute(e)||t&#125;function e(n)&#123;return document.getElementsByTagName(n)&#125;function t()&#123;var t=e(\"script\"),o=t.length,i=t[o-1];return&#123;l:o,z:n(i,\"zIndex\",-1),o:n(i,\"opacity\",.5),c:n(i,\"color\",\"0,0,0\"),n:n(i,\"count\",99)&#125;&#125;function o()&#123;a=m.width=window.innerWidth||document.documentElement.clientWidth||document.body.clientWidth,c=m.height=window.innerHeight||document.documentElement.clientHeight||document.body.clientHeight&#125;function i()&#123;r.clearRect(0,0,a,c);var n,e,t,o,m,l;s.forEach(function(i,x)&#123;for(i.x+=i.xa,i.y+=i.ya,i.xa*=i.x&gt;a||i.x&lt;0?-1:1,i.ya*=i.y&gt;c||i.y&lt;0?-1:1,r.fillRect(i.x-.5,i.y-.5,1,1),e=x+1;e&lt;u.length;e++)n=u[e],null!==n.x&amp;&amp;null!==n.y&amp;&amp;(o=i.x-n.x,m=i.y-n.y,l=o*o+m*m,l&lt;n.max&amp;&amp;(n===y&amp;&amp;l&gt;=n.max/2&amp;&amp;(i.x-=.03*o,i.y-=.03*m),t=(n.max-l)/n.max,r.beginPath(),r.lineWidth=t/2,r.strokeStyle=\"rgba(\"+d.c+\",\"+(t+.2)+\")\",r.moveTo(i.x,i.y),r.lineTo(n.x,n.y),r.stroke()))&#125;),x(i)&#125;var a,c,u,m=document.createElement(\"canvas\"),d=t(),l=\"c_n\"+d.l,r=m.getContext(\"2d\"),x=window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.oRequestAnimationFrame||window.msRequestAnimationFrame||function(n)&#123;window.setTimeout(n,1e3/45)&#125;,w=Math.random,y=&#123;x:null,y:null,max:2e4&#125;;m.id=l,m.style.cssText=\"position:fixed;top:0;left:0;z-index:\"+d.z+\";opacity:\"+d.o,e(\"body\")[0].appendChild(m),o(),window.onresize=o,window.onmousemove=function(n)&#123;n=n||window.event,y.x=n.clientX,y.y=n.clientY&#125;,window.onmouseout=function()&#123;y.x=null,y.y=null&#125;;for(var s=[],f=0;d.n&gt;f;f++)&#123;var h=w()*a,g=w()*c,v=2*w()-1,p=2*w()-1;s.push(&#123;x:h,y:g,xa:v,ya:p,max:6e3&#125;)&#125;u=s.concat([y]),setTimeout(function()&#123;i()&#125;,100)&#125;();&lt;/script&gt;&lt;div style = \"display:none;\"&gt; 动态线条end&lt;/div&gt; 6、目录 12345&lt;div style = \"display:none;\" &gt;index相关&lt;/div&gt;&lt;script src=\"http://cdn.bootcss.com/bootstrap/3.2.0/js/bootstrap.min.js\"&gt;&lt;/script&gt;&lt;link href=\"http://files.cnblogs.com/files/ning-wang/marvin.nav.css\" rel=\"stylesheet\"&gt;&lt;script type=\"text/javascript\" src=\"http://files.cnblogs.com/files/ning-wang/marvin.nav.js\"&gt;&lt;/script&gt;&lt;div style = \"display:none;\" &gt;index相关end&lt;/div&gt; 但是这种目录有个缺陷，在手机上会极其影响阅读。 所以最近换了另外一种目录，在文章顶部，而且有个 return to top，用起来也是不错的。(放在页脚 html ) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;script language=\"javascript\" type=\"text/javascript\"&gt;// 生成目录索引列表// ref: http://www.cnblogs.com/wangqiguo/p/4355032.html// modified by: zzqfunction GenerateContentList()&#123; var mainContent = $('#cnblogs_post_body'); var h2_list = $('#cnblogs_post_body h2');//如果你的章节标题不是h2,只需要将这里的h2换掉即可 if(mainContent.length &lt; 1) return; if(h2_list.length&gt;0) &#123; var content = '&lt;a name=\"_labelTop\"&gt;&lt;/a&gt;'; content += '&lt;div id=\"navCategory\" style=\"color:#152e97;\"&gt;'; content += '&lt;p style=\"font-size:18px;\"&gt;&lt;b&gt;目录&lt;/b&gt;&lt;/p&gt;'; content += '&lt;ul&gt;'; for(var i=0; i&lt;h2_list.length; i++) &#123; var go_to_top = '&lt;div style=\"text-align: right;\"&gt;&lt;a href=\"#_labelTop\" style=\"color:#f68a33\"&gt;回到顶部&lt;/a&gt;&lt;a name=\"_label' + i + '\"&gt;&lt;/a&gt;&lt;/div&gt;'; $(h2_list[i]).before(go_to_top); var h3_list = $(h2_list[i]).nextAll(\"h3\"); var li3_content = ''; for(var j=0; j&lt;h3_list.length; j++) &#123; var tmp = $(h3_list[j]).prevAll('h2').first(); if(!tmp.is(h2_list[i])) break; var li3_anchor = '&lt;a name=\"_label' + i + '_' + j + '\"&gt;&lt;/a&gt;'; $(h3_list[j]).before(li3_anchor); li3_content += '&lt;li&gt;&lt;a href=\"#_label' + i + '_' + j + '\"&gt;' + $(h3_list[j]).text() + '&lt;/a&gt;&lt;/li&gt;'; &#125; var li2_content = ''; if(li3_content.length &gt; 0) li2_content = '&lt;li&gt;&lt;a href=\"#_label' + i + '\"&gt;' + $(h2_list[i]).text() + '&lt;/a&gt;&lt;ul&gt;' + li3_content + '&lt;/ul&gt;&lt;/li&gt;'; else li2_content = '&lt;li&gt;&lt;a href=\"#_label' + i + '\"&gt;' + $(h2_list[i]).text() + '&lt;/a&gt;&lt;/li&gt;'; content += li2_content; &#125; content += '&lt;/ul&gt;'; content += '&lt;/div&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;'; content += '&lt;hr style=\"height:1px;border:none;border-top:1px dashed #0066CC;\"/&gt;'; if($('#cnblogs_post_body').length != 0 ) &#123; $($('#cnblogs_post_body')[0]).prepend(content); &#125; &#125; &#125;GenerateContentList();&lt;/script&gt; 7、旋转立方体 在博客侧边栏的旋转立方体，图片可以自行更换： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185&lt;div style = \"display:none;\"&gt;旋转立方体&lt;/div&gt;&lt;style&gt; /*最外层容器样式*/ .wrap &#123; width: 100px; height: 100px; margin: 150px; position: relative; &#125; /*包裹所有容器样式*/ .cube &#123; width: 50px; height: 50px; margin: 0 auto; transform-style: preserve-3d; transform: rotateX(-30deg) rotateY(-80deg); animation: rotate linear 20s infinite; &#125; @-webkit-keyframes rotate &#123; from &#123; transform: rotateX(0deg) rotateY(0deg); &#125; to &#123; transform: rotateX(360deg) rotateY(360deg); &#125; &#125; .cube div &#123; position: absolute; width: 200px; height: 200px; opacity: 0.8; transition: all .4s; &#125; /*定义所有图片样式*/ .pic &#123; width: 200px; height: 200px; &#125; .cube .out_front &#123; transform: rotateY(0deg) translateZ(100px); &#125; .cube .out_back &#123; transform: translateZ(-100px) rotateY(180deg); &#125; .cube .out_left &#123; transform: rotateY(-90deg) translateZ(100px); &#125; .cube .out_right &#123; transform: rotateY(90deg) translateZ(100px); &#125; .cube .out_top &#123; transform: rotateX(90deg) translateZ(100px); &#125; .cube .out_bottom &#123; transform: rotateX(-90deg) translateZ(100px); &#125; /*定义小正方体样式*/ .cube span &#123; display: block; width: 100px; height: 100px; position: absolute; top: 50px; left: 50px; &#125; .cube .in_pic &#123; width: 100px; height: 100px; &#125; .cube .in_front &#123; transform: rotateY(0deg) translateZ(50px); &#125; .cube .in_back &#123; transform: translateZ(-50px) rotateY(180deg); &#125; .cube .in_left &#123; transform: rotateY(-90deg) translateZ(50px); &#125; .cube .in_right &#123; transform: rotateY(90deg) translateZ(50px); &#125; .cube .in_top &#123; transform: rotateX(90deg) translateZ(50px); &#125; .cube .in_bottom &#123; transform: rotateX(-90deg) translateZ(50px); &#125; /*鼠标移入后样式*/ .cube:hover .out_front &#123; transform: rotateY(0deg) translateZ(200px); &#125; .cube:hover .out_back &#123; transform: translateZ(-200px) rotateY(180deg); &#125; .cube:hover .out_left &#123; transform: rotateY(-90deg) translateZ(200px); &#125; .cube:hover .out_right &#123; transform: rotateY(90deg) translateZ(200px); &#125; .cube:hover .out_top &#123; transform: rotateX(90deg) translateZ(200px); &#125; .cube:hover .out_bottom &#123; transform: rotateX(-90deg) translateZ(200px); &#125; &lt;/style&gt; &lt;!-- 外层最大容器 --&gt; &lt;div class=\"wrap\"&gt; &lt;!--包裹所有元素的容器--&gt; &lt;div class=\"cube\"&gt; &lt;!--前面图片 --&gt; &lt;div class=\"out_front\"&gt; &lt;img src=\"https://i.loli.net/2018/05/03/5aeb0eef73838.jpg\" class=\"pic\"&gt; &lt;/div&gt; &lt;!--后面图片 --&gt; &lt;div class=\"out_back\"&gt; &lt;img src=\"https://i.loli.net/2018/05/03/5aeb0f2fb9a83.jpg\" class=\"pic\"&gt; &lt;/div&gt; &lt;!--左面图片 --&gt; &lt;div class=\"out_left\"&gt; &lt;img src=\"https://i.loli.net/2018/05/03/5aeb0f55411f0.jpg\" class=\"pic\"&gt; &lt;/div&gt; &lt;!--右面图片 --&gt; &lt;div class=\"out_right\"&gt; &lt;img src=\"https://i.loli.net/2018/05/03/5aeb0f79a1124.jpg\" class=\"pic\"&gt; &lt;/div&gt; &lt;!--上面图片 --&gt; &lt;div class=\"out_top\"&gt; &lt;img src=\"https://i.loli.net/2018/05/03/5aeb0f98a8b66.jpg\" class=\"pic\"&gt; &lt;/div&gt; &lt;!--下面图片 --&gt; &lt;div class=\"out_bottom\"&gt; &lt;img src=\"https://i.loli.net/2018/05/03/5aeb0fdd51b7e.jpg\" class=\"pic\"&gt; &lt;/div&gt; &lt;!--小正方体 --&gt; &lt;span class=\"in_front\"&gt; &lt;img src=\"https://i.loli.net/2018/05/03/5aeb100223dd0.jpg\" class=\"in_pic\"&gt; &lt;/span&gt; &lt;span class=\"in_back\"&gt; &lt;img src=\"https://i.loli.net/2018/05/03/5aeb101c2c24b.jpg\" class=\"in_pic\"&gt; &lt;/span&gt; &lt;span class=\"in_left\"&gt; &lt;img src=\"https://i.loli.net/2018/05/03/5aeb1038127b5.jpg\" class=\"in_pic\"&gt; &lt;/span&gt; &lt;span class=\"in_right\"&gt; &lt;img src=\"https://i.loli.net/2018/05/03/5aeb0dce1ca55.jpg\" class=\"in_pic\"&gt; &lt;/span&gt; &lt;span class=\"in_top\"&gt; &lt;img src=\"https://i.loli.net/2018/05/03/5aeb1057bb167.jpg\" class=\"in_pic\"&gt; &lt;/span&gt; &lt;span class=\"in_bottom\"&gt; &lt;img src=\"https://i.loli.net/2018/05/03/5aeb107514579.jpg\" class=\"in_pic\"&gt; &lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&lt;div style = \"display:none;\"&gt;旋转立方体end&lt;/div&gt; 8、代码高亮 在页面定制 css 中加入： css123456789101112131415161718/*! Color themes for Google Code Prettify | MIT License | github.com/jmblog/color-themes-for-google-code-prettify */.pln&#123;color:#4d4d4c&#125;ol.linenums&#123;margin-top:0;margin-bottom:0;color:#8e908c&#125;li.L0,li.L1,li.L2,li.L3,li.L4,li.L5,li.L6,li.L7,li.L8,li.L9&#123;padding-left:1em;background-color:#fff;list-style-type:decimal!important;&#125;@media screen&#123;.str&#123;color:#718c00&#125;.kwd&#123;color:#8959a8&#125;.com&#123;color:#8e908c&#125;.typ&#123;color:#4271ae&#125;.lit&#123;color:#f5871f&#125;.pun&#123;color:#4d4d4c&#125;.opn&#123;color:#4d4d4c&#125;.clo&#123;color:#4d4d4c&#125;.tag&#123;color:#c82829&#125;.atn&#123;color:#f5871f&#125;.atv&#123;color:#3e999f&#125;.dec&#123;color:#f5871f&#125;.var&#123;color:#c82829&#125;.fun&#123;color:#4271ae&#125;&#125;/*下面是我设置背景色，字体大小和字体*/.cnblogs-markdown code&#123;background:#fff!important;&#125;.cnblogs_code,.cnblogs_code span,.cnblogs-markdown .hljs&#123; font-size:16px!important;&#125;.syntaxhighlighter a, .syntaxhighlighter div, .syntaxhighlighter code, .syntaxhighlighter table, .syntaxhighlighter table td, .syntaxhighlighter table tr, .syntaxhighlighter table tbody, .syntaxhighlighter table thead, .syntaxhighlighter table caption, .syntaxhighlighter textarea &#123; font-size: 16px!important;&#125;.cnblogs_code, .cnblogs_code span, .cnblogs-markdown .hljs&#123;font-family:consolas, \"Source Code Pro\", monaco, monospace !important;&#125; 在页脚 html 加入： html1234567&lt;script src=\"http://files.cnblogs.com/files/flipped/prettify.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt;(function() &#123; $(\"pre\").addClass(\"prettyprint\"); prettyPrint();&#125;)();&lt;/script&gt; 9、添加背景图片 选择 simplememory 主题，添加如下代码： css123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166/*simplememory*/#google_ad_c1, #google_ad_c2 &#123;display:none;&#125;.syntaxhighlighter a, .syntaxhighlighter div, .syntaxhighlighter code, .syntaxhighlighter table, .syntaxhighlighter table td, .syntaxhighlighter table tr, .syntaxhighlighter table tbody, .syntaxhighlighter table thead, .syntaxhighlighter table caption, .syntaxhighlighter textarea &#123;font-size: 14px!important;&#125;#home &#123;opacity: 0.80;margin: 0 auto;width: 85%;min-width: 950px;background-color: #fff;padding: 30px;margin-top: 30px;margin-bottom: 50px;box-shadow: 0 2px 6px rgba(100, 100, 100, 0.3);&#125;#blogTitle h1 &#123;font-size: 30px;font-weight: bold;font-family: \"Comic Sans MS\";line-height: 1.5em;margin-top: 20px;color: #515151;&#125;#navList a:hover &#123;color: #4C9ED9;text-decoration: none;&#125;#navList a &#123;display: block;width: 5em;height: 22px;float: left;text-align: center;padding-top: 18px;&#125;#navigator &#123;font-size: 15px;border-bottom: 1px solid #ededed;border-top: 1px solid #ededed;height: 50px;clear: both;margin-top: 25px;&#125;.catListTitle &#123;margin-top: 21px;margin-bottom: 10.5px;text-align: left;border-left: 10px solid rgba(82, 168, 236, 0.8);padding: 10px 0 14px 10px;background-color: #f5f5f5;&#125;#ad_under_post_holder #google_ad_c1,#google_ad_c2&#123; display: none !important;&#125;body &#123;color: #000;background: url(https://i.loli.net/2018/05/03/5aeb107514579.jpg) fixed;background-size: 100%;background-repeat: no-repeat;font-family: \"Helvetica Neue\",Helvetica,Verdana,Arial,sans-serif;font-size: 12px;min-height: 101%;&#125;#topics .postTitle &#123;border: 0px;font-size: 200%;font-weight: bold;float: left;line-height: 1.5;width: 100%;padding-left: 5px;&#125;div.commentform p&#123;margin-bottom:10px;&#125;.comment_btn &#123;padding: 5px 10px;height: 35px;width: 90px;border: 0 none;border-radius: 5px;background: #ddd;color: #999;cursor:pointer;font-family: \"Lato\", Helvetica Neue, Helvetica, Microsoft Yahei, 宋体, Arial, sans-serif;text-shadow: 0 0 1px #fff;display: inline !important;&#125;.comment_btn:hover&#123;padding: 5px 10px;height: 35px;width: 90px;border: 0 none;border-radius: 5px;background: #258fb8;color: white;cursor:pointer;font-family: \"Lato\", Helvetica Neue, Helvetica, Microsoft Yahei, 宋体, Arial, sans-serif;text-shadow: 0 0 1px #fff;display: inline !important;&#125;#commentform_title &#123;background-image:none;background-repeat:no-repeat;margin-bottom:10px;padding:0;font-size:24px;&#125;#commentbox_opt,#commentbox_opt + p &#123;text-align:center;&#125;.commentbox_title &#123;width: 100%;&#125;#tbCommentBody &#123;font-family:'Microsoft Yahei', Microsoft Yahei, 宋体, sans-serif;margin-top:10px;max-width:100%;min-width:100%;background:white;color:#333;border:2px solid #fff;box-shadow:inset 0 0 8px #aaa;// padding:10px;height:250px;font-size:14px;min-height:120px;&#125;.feedbackItem &#123;font-size:14px;line-height:24px;margin:10px 0;padding:20px;background:#F2F2F2;box-shadow:0 0 5px #aaa;&#125;.feedbackListSubtitle &#123;font-weight:normal;&#125;#blog-comments-placeholder, #comment_form &#123;padding: 20px;background: #fff;-webkit-box-shadow: 1px 2px 3px #ddd;box-shadow: 1px 2px 3px #ddd;margin-bottom: 50px;&#125;.feedback_area_title &#123;margin-bottom: 15px;font-size: 1.8em;&#125;.feedbackItem &#123;border-bottom: 1px solid #CCC;margin-bottom: 10px;padding: 5px;background: rgb(248, 248, 248);&#125;.color_shine &#123;background: rgb(226, 242, 255);&#125;.feedbackItem:hover &#123;-webkit-animation-name: color_shine;-webkit-animation-duration: 2s;-webkit-animation-iteration-count: infinite;&#125;#comment_form .title &#123;font-weight: normal;margin-bottom: 15px;&#125; 将代码中的图片地址改成自己的就行。 10、雪花效果 添加 js 文件 前提是开通了 js 权限，然后把 xue.js 文件上传到自己博客中； 创建画布（放在页尾）： 123&lt;div class=\"Snow\"&gt; &lt;canvas id=\"Snow\"&gt;&lt;/canvas&gt;&lt;/div&gt; 引入 js 文件(放在页尾)； Javascript1&lt;script src=\"https://files.cnblogs.com/files/yjlblog/xue.js\"&gt;&lt;/script&gt; js 文件： Javascript123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115(function() &#123; var requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame || function(callback) &#123; window.setTimeout(callback, 1000 / 60); &#125;; window.requestAnimationFrame = requestAnimationFrame;&#125;)();(function() &#123; var flakes = [], canvas = document.getElementById(\"Snow\"), //画布ID，与上一步创建的画布对应 ctx = canvas.getContext(\"2d\"), flakeCount = 200, //雪花数量，数值越大雪花数量越多 mX = -100, mY = -100; canvas.width = window.innerWidth; canvas.height = window.innerHeight; function snow() &#123; ctx.clearRect(0, 0, canvas.width, canvas.height); for (var i = 0; i &lt; flakeCount; i++) &#123; var flake = flakes[i], x = mX, y = mY, minDist = 150, //雪花距离鼠标指针的最小值，小于这个距离的雪花将受到鼠标的排斥 x2 = flake.x, y2 = flake.y; var dist = Math.sqrt((x2 - x) * (x2 - x) + (y2 - y) * (y2 - y)), dx = x2 - x, dy = y2 - y; if (dist &lt; minDist) &#123; var force = minDist / (dist * dist), xcomp = (x - x2) / dist, ycomp = (y - y2) / dist, deltaV = force / 2; flake.velX -= deltaV * xcomp; flake.velY -= deltaV * ycomp; &#125; else &#123; flake.velX *= .98; if (flake.velY &lt;= flake.speed) &#123; flake.velY = flake.speed &#125; flake.velX += Math.cos(flake.step += .05) * flake.stepSize; &#125; ctx.fillStyle = \"rgba(255,255,255,\" + flake.opacity + \")\"; //雪花颜色 flake.y += flake.velY; flake.x += flake.velX; if (flake.y &gt;= canvas.height || flake.y &lt;= 0) &#123; reset(flake); &#125; if (flake.x &gt;= canvas.width || flake.x &lt;= 0) &#123; reset(flake); &#125; ctx.beginPath(); ctx.arc(flake.x, flake.y, flake.size, 0, Math.PI * 2); ctx.fill(); &#125; requestAnimationFrame(snow); &#125;; function reset(flake) &#123; flake.x = Math.floor(Math.random() * canvas.width); flake.y = 0; flake.size = (Math.random() * 3) + 2; //加号后面的值，雪花大小，为基准值，数值越大雪花越大 flake.speed = (Math.random() * 1) + 0.5; //加号后面的值，雪花速度，为基准值，数值越大雪花速度越快 flake.velY = flake.speed; flake.velX = 0; flake.opacity = (Math.random() * 0.5) + 0.3; //加号后面的值，为基准值，范围0~1 &#125; function init() &#123; for (var i = 0; i &lt; flakeCount; i++) &#123; var x = Math.floor(Math.random() * canvas.width), y = Math.floor(Math.random() * canvas.height), size = (Math.random() * 3) + 2, //加号后面的值，雪花大小，为基准值，数值越大雪花越大 speed = (Math.random() * 1) + 0.5, //加号后面的值，雪花速度，为基准值，数值越大雪花速度越快 opacity = (Math.random() * 0.5) + 0.3; //加号后面的值，为基准值，范围0~1 flakes.push(&#123; speed: speed, velY: speed, velX: 0, x: x, y: y, size: size, stepSize: (Math.random()) / 30 * 1, //乘号后面的值，雪花横移幅度，为基准值，数值越大雪花横移幅度越大，0为竖直下落 step: 0, angle: 180, opacity: opacity &#125;); &#125; snow(); &#125;; document.addEventListener(\"mousemove\", function(e) &#123; mX = e.clientX, mY = e.clientY &#125;); window.addEventListener(\"resize\", function() &#123; canvas.width = window.innerWidth; canvas.height = window.innerHeight; &#125;); init();&#125;)(); 添加样式（自定义 css，背景颜色可以自己改变）； css12345678910#Snow&#123; position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 99999; background: rgba(125,137,95,0.1); pointer-events: none;&#125; 11、去除广告 在页面定制 css 添加代码： css123456789101112131415161718192021222324252627282930#google_ad_c1,#div-gpt-ad-1320933818841-0,#google_ad_c2,#div-gpt-ad-1320933818841-1,#ad_under_google&#123;display:none;visibility：hidden;&#125;#under_post_kb,#under_post_news&#123; display:none;&#125;#site_nav_under &#123; display: none;&#125;.c_ad_block, .ad_text_commentbox &#123; display: none; margin: 0; padding: 0;&#125;#ad_under_google &#123; height: 0; overflow: hidden;&#125;#ad_under_google a &#123; display: none;&#125;#ad_t2&#123; display:none &#125;#div_digg&#123; display:none &#125;#author_profile_info&#123; display:none &#125;.postDesc&#123; display:none &#125; 12、公告栏时钟 博客侧边栏公告代码： 12345&lt;!-- 添加公告栏时钟 --&gt;&lt;div id=\"clockdiv\"&gt; &lt;canvas id=\"dom\" width=\"120\" height=\"120\"&gt;时钟canvas&lt;/canvas&gt;&lt;/div&gt;&lt;script type=\"text/javascript\" src=\"https://files.cnblogs.com/files/shwee/clock.js\"&gt;&lt;/script&gt; 页面定制 CSS 代码： css12345/* 定制公告栏时钟位置 */#clockdiv &#123; /* left, center, right */ text-align: center;&#125; 13、添加公告栏文字信息 博客侧边栏公告代码： html12345&lt;p class=\"gonggao\"&gt;&lt;a style=\"color: blue;font-weight: bold;\" href=\"http://www.cnblogs.com/shwee/p/9056959.html\"&gt;我的博客目录结构&lt;/a&gt;&lt;/p&gt;&lt;p class=\"wenzi\"&gt;欢迎来到我的博客&lt;/p&gt;&lt;p&gt;-------------------------------&lt;/p&gt; 页面定制 CSS 代码： css12345678910/* 定制公告栏文字信息 */.gonggao&#123; text-align: center; font-size:17px; color:blue;&#125;.wenzi&#123; text-align: center; font-size:15px;&#125; 14、点击爱心效果 为页面添加鼠标点击心形特效，代码放在 “博客侧边栏公告（支持 HTML 代码）（支持 JS 代码）”框中，代码如下： Javascript123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;!-- 为页面添加爱心特效 --&gt;&lt;script type=\"text/javascript\"&gt;(function(window,document,undefined)&#123; var hearts = []; s window.requestAnimationFrame = (function()&#123; return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (callback)&#123; setTimeout(callback,1000/60); &#125; &#125;)(); init(); function init()&#123; css(\".heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: absolute;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;\"); attachEvent(); gameloop(); &#125; function gameloop()&#123; for(var i=0;i&lt;hearts.length;i++)&#123; if(hearts[i].alpha &lt;=0)&#123; document.body.removeChild(hearts[i].el); hearts.splice(i,1); continue; &#125; hearts[i].y--; hearts[i].scale += 0.004; hearts[i].alpha -= 0.013; hearts[i].el.style.cssText = \"left:\"+hearts[i].x+\"px;top:\"+hearts[i].y+\"px;opacity:\"+hearts[i].alpha+\";transform:scale(\"+hearts[i].scale+\",\"+hearts[i].scale+\") rotate(45deg);background:\"+hearts[i].color; &#125; requestAnimationFrame(gameloop); &#125; function attachEvent()&#123; var old = typeof window.onclick===\"function\" &amp;&amp; window.onclick; window.onclick = function(event)&#123; old &amp;&amp; old(); createHeart(event); &#125; &#125; function createHeart(event)&#123; var d = document.createElement(\"div\"); d.className = \"heart\"; hearts.push(&#123; el : d, x : event.clientX - 5, y : event.clientY - 5, scale : 1, alpha : 1, color : randomColor() &#125;); document.body.appendChild(d); &#125; function css(css)&#123; var style = document.createElement(\"style\"); style.type=\"text/css\"; try&#123; style.appendChild(document.createTextNode(css)); &#125; catch(ex)&#123; style.styleSheet.cssText = css; &#125; document.getElementsByTagName('head')[0].appendChild(style); &#125; function randomColor()&#123; return \"rgb(\"+(~~(Math.random()*255))+\",\"+(~~(Math.random()*255))+\",\"+(~~(Math.random()*255))+\")\"; &#125; &#125;)(window,document);&lt;/script&gt;","categories":[{"name":"Blog","slug":"Blog","permalink":"https://zhangxiaocn.github.io/categories/Blog/"}],"tags":[{"name":"Blog","slug":"Blog","permalink":"https://zhangxiaocn.github.io/tags/Blog/"},{"name":"博客园","slug":"博客园","permalink":"https://zhangxiaocn.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"},{"name":"美化","slug":"美化","permalink":"https://zhangxiaocn.github.io/tags/%E7%BE%8E%E5%8C%96/"}]},{"title":"PID 基础公式及程序","slug":"study-note-pid","date":"2019-10-30T12:21:32.000Z","updated":"2020-01-08T14:24:43.831Z","comments":true,"path":"2019/10/30/study-note-pid/","link":"","permalink":"https://zhangxiaocn.github.io/2019/10/30/study-note-pid/","excerpt":"","text":"仅用于备份本人所写笔记，如有错误或不完善之处还请包含。转载请注明出处！ 1、位置式离散 PID： $ Pwm = Kp \\times e(k) + Ki \\times \\sum e(k) + Kd \\times [e(k) - e(k-1)] $ $ e(k) $ : 本次偏差 $ e(k-1) $ : 上次偏差 $ \\sum e(k) $ : $ e(k) $ 以及之前的偏差的累计和，其中 $ k $ 为 $ 1, 2, 3\\ldots k $ $ Pwm $ : 代表输出 C 语言的实现： c12345678910111213141516// 位置式离散 PID// P = Kp * err;// I = Ki * integral_err;// D = Kd * (err - last_err);// Pwm = P + I + D;float PositionPid(int encoder, int target) &#123; static float err = 0, last_err = 0, integral_err = 0, pwm = 0; float kp = 1, ki = 1, kd = 1; err = encoder - target; // 计算偏差 integral_err += err; // 求出偏差积分 pwm = kp * err + ki * integral_err + kd * (err - last_err); last_err = err; // 保存上一次偏差 return pwm; // 输出&#125; 在舵机角度控制闭环系统里，只使用 PD 控制，因此可将 PID 控制简化为此公式： $ Pwm = Kp \\times e(k) + Kd \\times [e(k) - e(k-1)] $ 代码更改如下： c1234567891011121314// 位置式离散 PD// P = Kp * err;// D = Kd * (err - last_err);// Pwm = P + D;float PositionPid(int encoder, int target) &#123; static float err = 0, last_err = 0, integral_err = 0, pwm = 0; float kp = 1, ki = 1, kd = 1; err = encoder - target; // 计算偏差 pwm = kp * err + kd * (err - last_err); last_err = err; // 保存上一次偏差 return pwm; // 输出&#125; PID 参数整定： P：用于提高相应速度 I：用于减小静差 D：用于抑制震荡 2、增量式离散 PID： $ Pwm += Kp × [e(k) - e(k-1)] + Ki × e(k) + Kd × [e(k) - 2e(k-1) + e(k-2)] $ $ e(k) $ : 本次偏差 $ e(k-1) $ : 上次的偏差 $ e(k-2) $ : 上上次的偏差 $ Pwm $ : 代表增量输出 C 语言实现： c1234567891011121314151617// 增量式离散 PID// P = Kp * (err - last_err);// I = Ki * err;// D = Kd * (err - 2 * last_err + before_err);// Pwm += P + I + D;float IncrementalPid(int encoder, int target) &#123; static float err = 0, last_err = 0, before_err = 0, pwm = 0; float kp = 1, ki = 1, kd = 1; err = encoder - target; // 计算偏差 pwm += kp * (err - last_err) + ki * err + kd * (err - 2 * last_err + before_err); // 增量式 PI 控制器 before_err = last_err; // 保存上上次偏差 last_err = err; // 保存上一次偏差 return pwm; // 增量输出&#125; 在速度控制闭环系统里，只使用 PI 控制，因此可将 PID 控制简化为此公式： $ Pwm += Kp × [e(k) - e(k-1)] + Ki × e(k) $ 代码更改如下： c1234567891011121314// 增量式离散 PI// P = Kp * (err - last_err);// I = Ki * err;// Pwm += P + I;float IncrementalPid(int encoder, int target) &#123; static float err = 0, last_err = 0, pwm = 0; float kp = 1, ki = 1, kd = 1; err = encoder - target; // 计算偏差 pwm += kp * (err - last_err) + ki * err; // 增量式 PI 控制器 last_err = err; // 保存上一次偏差 return pwm; // 增量输出&#125;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://zhangxiaocn.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"PID","slug":"PID","permalink":"https://zhangxiaocn.github.io/tags/PID/"}]},{"title":"K60 定时器中断的使用","slug":"k60-time-interrupt","date":"2019-10-30T12:16:02.000Z","updated":"2019-10-30T13:16:57.090Z","comments":true,"path":"2019/10/30/k60-time-interrupt/","link":"","permalink":"https://zhangxiaocn.github.io/2019/10/30/k60-time-interrupt/","excerpt":"","text":"仅用于备份本人所写笔记，如有错误或不完善之处还请包含。转载请注明出处！ 程序使用逐飞科技 K60 库 V2.0.3 首先，中断需要初始化以及定义中断的时间： c1pit_init_ms(pit1, 1); // 设置中断时间为 1ms 中断时间过长，会造成程序运行后出现的效果非常迟钝。 中断时间过短，可能会使中断里的程序运行时间不够，从而造成溢出。 所以在时间方面需要细心拿捏。 设置中断的优先级： c1set_irq_priority(PIT1_IRQn, 1); // 设置优先级 设置完成后，就可以打开中断，开始运行： c1enable_irq(PIT1_IRQn); // 打开中断 1 运行中断时，需要注意中断里的程序最好不要过多，尽可能不要有延时函数。 c1234567// 中断 1void PIT1_IRQHandler(void) &#123; // 用户程序 PIT_FlAG_CLR(pit1); // 中断标志清除&#125; 这样就基本实现了中断的初始化及运行。 当然我们也可以同时用两个甚至多个中断，让它们同时运行。但是，中断过多可能会出现一些问题。比如： 出现同时两个中断满足进入中断的条件时，这时就会根据中断优先级进行判断先进入哪个中断服务程序里，高优先级的执行完毕才会进入低优先级中断。 如果正在执行中断服务程序（中断1）时，另一个中断（中断2）触发，如果 2 优先级高于 1，那么会立即执行中断2的服务程序，等中断2 执行完毕，才会继续执行中断1。如果中断 2 优先级低于中断1，则等待中断1 执行完毕才会执行中断2。 也就是说，如果两个或者多个中断同时满足运行条件，可能会造成低优先级中断里的程序没有机会运行，从而影响使用。所以，没有太大必要的情况下，不建议同时使用多个中断。 那么，如果只用一个中断，而我又需要让程序在不同的时间下运行该怎么办呢？ 如下给出一个可行的方案： c1234567891011121314151617181920212223// 中断 0，计时 1msvoid PIT0_IRQHandler(void) &#123; timeCount++; // 每运行一次中断，值 +1 if (timeCount % 1 == 0 ) &#123; timeFlag_1ms = 1; &#125; // 1ms 标志 if (timeCount % 2 == 0 ) &#123; timeFlag_2ms = 1; &#125; // 2ms 标志 if (timeCount % 5 == 0 ) &#123; timeFlag_5ms = 1; &#125; // 5ms 标志 if (timeCount % 10 == 0 ) &#123; timeFlag_10ms = 1; &#125; // 10ms 标志 if (timeCount % 20 == 0 ) &#123; timeFlag_20ms = 1; &#125; // 20ms 标志 if (timeCount % 50 == 0 ) &#123; timeFlag_50ms = 1; &#125; // 50ms 标志 if (timeCount % 200 == 0 ) &#123; timeFlag_200ms = 1; timeCount = 0; &#125; // 200ms 标志，并清除计时标志 if (timeFlag_1ms == 1) &#123; timeFlag_1ms = 0; ... &#125; // 每 1ms 运行一次程序 if (timeFlag_2ms == 1) &#123; timeFlag_2ms = 0; ... &#125; // 每 2ms 运行一次程序 if (timeFlag_5ms == 1) &#123; timeFlag_5ms = 0; ... &#125; // 每 5ms 运行一次程序 if (timeFlag_10ms == 1) &#123; timeFlag_10ms = 0; ... &#125; // 每 10ms 运行一次程序 if (timeFlag_20ms == 1) &#123; timeFlag_20ms = 0; ... &#125; // 每 20ms 运行一次程序 if (timeFlag_50ms == 1) &#123; timeFlag_50ms = 0; ... &#125; // 每 50ms 运行一次程序 if (timeFlag_200ms == 1) &#123; timeFlag_200ms = 0; ... &#125; // 每 200ms 运行一次程序 PIT_FlAG_CLR(pit0); // 中断标志清除&#125; 如上，让中断里的程序每 200ms 实现一次循环。只要将每个程序的运行时间设置到位，便可以让各个程序在不同的时间下运行。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://zhangxiaocn.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"K60","slug":"K60","permalink":"https://zhangxiaocn.github.io/tags/K60/"}]},{"title":"OpenMV 扫描 QR 码 + 串口通信","slug":"openmv-study-note-1","date":"2019-10-29T13:46:29.000Z","updated":"2020-01-08T15:27:11.603Z","comments":true,"path":"2019/10/29/openmv-study-note-1/","link":"","permalink":"https://zhangxiaocn.github.io/2019/10/29/openmv-study-note-1/","excerpt":"","text":"部分内容来自 凡哥带你玩转OpenMV 以及 OpenMV中文入门教程。 1、使用 TTL-USB 模块 备份一下我用的 TTL-USB 模块各接口，红线是 5V ，粉色线是 3V3 ，蓝色线是 TX ，绿色线是 RX ，黑色线是 GND 两个单片机进行串口通信，最少需要三根线相连： 发送端 TX 接收端 RX 地线 GND 例如 A 和 B 两个单片机，A 的 RX 需要接 B 的 TX ，B 的 RX 需要接 A 的 TX ，二者的地线 GND 相连作为参考电平。 VCC 可接可不接，USB 的串口是 5V 的，如果要接 OpenMV 板子上的话， 需要接在 OpenMV 的 VIN 上， 如果接在 3v3, 也就是 3.3v 的接口处， 会使所有的元器件暴露在 5v 的电压下， 导致电子元器件全部烧毁。 2、OpenMV 串口资源 OpenMV 引脚图 UART 3 ： Pin Name Uart Index Role P4 串口 3 TX 发送端 P5 串口 3 RX 接收端 3、串口助手 推荐下载星瞳串口助手：https://singtown.com/singtownserialport/ 或者友善串口调试助手，百度搜索下载即可。 软件设置： 波特率：115200 数据为：8 校验位：None 停止位：1 流控：None 接收设置：ASCII 发送设置：Hex 4、串口通信程序 4.1、UART 对象 更多详细操作请转到 UART 官方文档： http://docs.micropython.org/en/latest/pyboard/library/pyb.UART.html?highlight=uart 初始化UART对象： c123456/** 初始化一个串口对象* uart_idx , 串口 ID， 我们这里只能写 1 或者 3* baud_rate , 波特率 */UART(uart_idx, baud_rate) python12# 初始化 UART 对象uart = UART(3, 115200) 更多操作： python123456# 读写操作uart.read(10) # 读入 10 个字符， 返回一个比特对象 uart.read() # 读取所有的有效字符uart.readline() # 读入一行uart.readinto(buf) # 读入并且保存在缓存中uart.write('abc') # 向串口写入3个字符abc python123# 单个字符的读取与写入uart.readchar() # 读入一个字符uart.writechar(42) # 写入 ASCALL 码为 42 的字符 python12# 判断串口是否有数据uart.any() 4.2、向串口发送数据 python12345678910import timefrom pyb import UART# 初始化 UART 对象uart = UART(3, 115200)uart.init(115200, bits=8, parity=None, stop=1) # init with given parameterswhile(True): uart.write(\"Hello World!!!\\r\") print(\"Hello World\") time.sleep(1000) # 休眠 1s 4.3、向串口接收数据 python1234567891011121314import timefrom pyb import UART# 初始化 UART 对象uart = UART(3, 115200)uart.init(115200, bits=8, parity=None, stop=1) # init with given parameterswhile(True): # 判断是否有数据 if uart.any(): tmp_data = uart.readline() print(tmp_data) time.sleep(1000) # 休眠 1s 4.4、数据双向发送与接收 python123456789101112131415161718192021222324import timefrom pyb import UART# 初始化 UART 对象uart = UART(3, 115200)uart.init(115200, bits=8, parity=None, stop=1) # init with given parameters# 发送数据def sending_data(): global uart uart.write(\"HelloWorld!!!\\n\")# 接收数据def recive_data(): global uart if uart.any(): tmp_data = uart.readline() uart.write(\"Recived : %s\\n\" % tmp_data) print(tmp_data)while(True): sending_data() recive_data() time.sleep(1000) # 休眠 1s 5、扫描 QR 码 可以用 草料二维码 生成想要的 QR 码内容 程序如下： python1234567891011121314151617import sensor, imagesensor.reset()sensor.set_pixformat(sensor.RGB565)sensor.set_framesize(sensor.QQVGA) # can be QVGA on M7...sensor.skip_frames(30) # 修改 sensor 配置之后，跳过30帧sensor.set_auto_gain(False) # must turn this off to prevent image washout...while(True): img = sensor.snapshot() # 拍摄一张照片，snapshot() 函数返回一个 image 对象 img.lens_corr(1.8) # strength of 1.8 is good for the 2.8mm lens. # 用来防止 115 度的摄像头拍摄出来的图像畸变(鱼眼) for code in img.find_qrcodes(): # find_qrcodes 用于寻找二维码 print(code) # 返回对象格式如下： # &#123;x:**, y:**, w:**, h:**, payload:\"**\", version:*, ecc_level:*, mask:*, data_type:*, eci:*&#125; # payload 就是在二维码下隐藏的信息 6、扫描 QR 码后通过串口发送数据 简单说就是把串口发送数据程序和扫描 QR 码程序放在一块就好了 python12345678910111213141516171819202122232425import timefrom pyb import UARTimport sensor, imagesensor.reset()sensor.set_pixformat(sensor.RGB565)sensor.set_framesize(sensor.QQVGA) # can be QVGA on M7...sensor.skip_frames(30) # 修改 sensor 配置之后，跳过30帧sensor.set_auto_gain(False) # must turn this off to prevent image washout...# 初始化 UART 对象uart = UART(3, 115200)uart.init(115200, bits = 8, parity = None, stop = 1)while(True): img = sensor.snapshot() # 拍摄一张照片，snapshot() 函数返回一个 image 对象 img.lens_corr(1.8) # 用来防止 115 度的摄像头拍摄出来的图像畸变(鱼眼) for code in img.find_qrcodes(): # find_qrcodes 用于寻找二维码 uart.write(code.payload()) # 串口读取二维码数据 # if code = \"123\" # 返回对象格式如下： # &#123;x, y, w, h, payload:\"**\", version:*, ecc_level:*, mask:*, data_type:*, eci:*&#125; # payload 就是我们在二维码下隐藏的信息 print(code) # 输出二维码内容 time.sleep(500) # 休息 0.5s","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://zhangxiaocn.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"OpenMV","slug":"OpenMV","permalink":"https://zhangxiaocn.github.io/tags/OpenMV/"}]},{"title":"简述 K60 直流电机闭环控制","slug":"k60-motor-control","date":"2019-10-29T13:41:02.000Z","updated":"2019-10-29T13:44:33.298Z","comments":true,"path":"2019/10/29/k60-motor-control/","link":"","permalink":"https://zhangxiaocn.github.io/2019/10/29/k60-motor-control/","excerpt":"","text":"仅用于备份本人所写笔记，如有错误或不完善之处还请包含。转载请注明出处！ 程序使用逐飞科技 K60 库 V2.0.3 电机速度闭环控制，简单来说就是将电机的输出量（速度）通过编码器反馈到控制端（单片机），然后对该输出量和设定的输入量进行比对，接着经过 PID 运算，将运算结果输入给电机的过程。 电机速度闭环一个显而易见的好处就是，可以让小车在不同的路段动态调整小车的速度，如果参数调整的好，可以让小车极大的提升对赛道的适应性能，减少小车跑完一圈所需的时间。 闭环控制思路比较简单，首先需要获取编码器的值，每 4ms 取一次值（可以设定其他时间），然后将取到的值进行相应的计算，得出电机当前速度。 代码示例： c123456789101112131415161718192021222324252627282930313233343536const float unit_pulse = 1783.0; // 小车轮胎旋转一周（360°）的脉冲const float motor_radius = 0.063; // 电机轮胎半径（米）// 编码器初始化void EncoderInit(void) &#123; ftm_quad_init(ftm2); // 初始化 ftm2 为正交解码 port_init_NoAlt(B18, PULLUP); // 上拉 port_init_NoAlt(B19, PULLUP); // 上拉&#125;// 读取编码器值float EncoderRead(void) &#123; float data = 0; data = ftm_quad_get(ftm2); // 获取编码器的脉冲值 ftm_quad_clean(ftm2); // 清除正交解码的脉冲值 return data;&#125;// 计算电机当前速度// 输入值为运行该程序的间隔时间float GetMotorSpeed(uint16 run_time_ms) &#123; float motor_speed = 0; encoder.finalValue += 0.25f * (encoder.value - encoder.finalValue); // 一阶低通滤波 encoder.motorRounds = (encoder.finalValue * run_time_ms) / unit_pulse; // 电机每 1s 转的圈数 encoder.motorDistance = encoder.motorRounds * (2 * PI * motor_radius); // 电机运行长度 m motor_speed = encoder.motorDistance / 1; // 电机速度 m/s return motor_speed;&#125; 计算出速度后，把该变量赋值给 PID 计算，算出需要输出给电机的占空比。PID 计算公式可以根据实际情况稍作修改优化。 代码示例： c1234567891011121314151617181920// 电机 pid 程序void MotorPid(void) &#123; static float err, last_err, expect_pwm; // 请根据实际情况修改 KP、KI 参数大小 motor_pid.kp = 0.1; motor_pid.ki = 0.2; err = motor.expectSpeed - encoder.motorSpeed; expect_pwm += motor_pid.kp * (err - last_err) + motor_pid.ki * err; last_err = err; // 电机占空比限幅 // 请根据实际情况修改最大和最小 PWM 参数值 if (expect_pwm &gt; 260) expect_pwm = 260; if (expect_pwm &lt;= 0) expect_pwm = 0; // 将值转换为正整数类型 motor.expectDutyRatio = (uint16)(expect_pwm);&#125; PID 返回期望占空比赋值给电机控制函数： c12345// 电机控制程序void MotorControl(void) &#123; MotorPid(); MotorPWM(0, motor.expectDutyRatio);&#125; 这样就实现了简单的电机速度闭环控制。当然这只算是比较基础的闭环，若要实现复杂功能，还需进行大量优化。 如下为本文闭环全部代码： c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124/******************************************************************************************* * COPYRIGHT NOTICE * Copyright (c) 2019, ZhangXiao * All rights reserved. * * 本文件仅供参考交流，未经允许不得用于商业用途！ * * File : motor.c * Author : ZhangXiao * Blog : zhangxiaocn.github.io * Version : v1.0.1 * Date : 2019-08-06 * Software : IAR 7.70.1 * Description : 电机相关程序以及 PID、编码器程序等 * note : None********************************************************************************************/#include \"motor.h\"#include \"headfile.h\"const float unit_pulse = 1783.0; // 小车轮胎旋转一周（360°）的脉冲const float motor_radius = 0.063; // 电机轮胎半径（米）// 电机 pid 程序结构体参数struct MOTOR_PID motor_pid = &#123;0.1, 0.2, 0, 0, 0, 0, 0, 0&#125;;// 编码器结构体struct ENCODER encoder = &#123;0, 0, 0, 0, 0&#125;;// 电机结构体struct MOTOR motor = &#123;0, 0, 0&#125;;// 电机初始化// FTM1_CH0_PIN 端口为 A12// FTM1_CH1_PIN 端口为 A13// 电机初始化频率默认为 10k，请根据实际情况更改频率大小void MotorInit(void) &#123; ftm_pwm_init(ftm1, ftm_ch0, 10 * 1000, 0); ftm_pwm_init(ftm1, ftm_ch1, 10 * 1000, 0);&#125;// 电机 PWM 控制void MotorPWM(uint16 pwm_1, uint16 pwm_2) &#123; ftm_pwm_duty(ftm1, ftm_ch0, pwm_1); // A12 端口 ftm_pwm_duty(ftm1, ftm_ch1, pwm_2); // A13 端口&#125;// 编码器初始化void EncoderInit(void) &#123; ftm_quad_init(ftm2); // 初始化 ftm2 为正交解码 port_init_NoAlt(B18, PULLUP); // 上拉 port_init_NoAlt(B19, PULLUP); // 上拉&#125;// 读取编码器值float EncoderRead(void) &#123; float data = 0; data = ftm_quad_get(ftm2); // 获取编码器的脉冲值 ftm_quad_clean(ftm2); // 清除正交解码的脉冲值 return data;&#125;// 计算电机当前速度// 输入值为运行该程序的间隔时间float GetMotorSpeed(uint16 run_time_ms) &#123; float motor_speed = 0; encoder.finalValue += 0.25f * (encoder.value - encoder.finalValue); // 一阶低通滤波 encoder.motorRounds = (encoder.finalValue * run_time_ms) / unit_pulse; // 电机每 1s 转的圈数 encoder.motorDistance = encoder.motorRounds * (2 * PI * motor_radius); // 电机运行长度 m motor_speed = encoder.motorDistance / 1; // 电机速度 m/s return motor_speed;&#125;// 计算电机运行距离// 输入值为运行该程序的间隔时间float GetMotorDistance(uint16 run_time_ms) &#123; return encoder.motorDistance / run_time_ms;&#125;// 编码器相关参数计算// 输入值为运行该程序的间隔时间// 程序建议每 4ms 运行一次，即 Encoder_Calculate(4);void EncoderCalculate(uint16 run_time_ms) &#123; uint16 run_time = 1000 / run_time_ms; // 每秒钟运行此程序次数 encoder.value = EncoderRead(); // 读取编码器的值 encoder.motorSpeed = GetMotorSpeed(run_time); // 计算电机当前速度 motor.distance += GetMotorDistance(run_time); // 获取电机距离&#125;// 电机 pid 程序void MotorPid(void) &#123; static float err, last_err, expect_pwm; // 请根据实际情况修改 KP、KI 参数大小 motor_pid.kp = 0.1; motor_pid.ki = 0.2; err = motor.expectSpeed - encoder.motorSpeed; expect_pwm += motor_pid.kp * (err - last_err) + motor_pid.ki * err; last_err = err; // 电机占空比限幅 // 请根据实际情况修改最大和最小 PWM 参数值 if (expect_pwm &gt; 260) expect_pwm = 260; if (expect_pwm &lt;= 0) expect_pwm = 0; // 将值转换为正整数类型 motor.expectDutyRatio = (uint16)(expect_pwm);&#125;// 电机控制程序void MotorControl(void) &#123; MotorPid(); MotorPWM(0, motor.expectDutyRatio);&#125;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://zhangxiaocn.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"K60","slug":"K60","permalink":"https://zhangxiaocn.github.io/tags/K60/"}]},{"title":"IAR 软件自用技巧","slug":"iar-setting","date":"2019-10-29T13:35:35.000Z","updated":"2020-01-08T14:48:10.178Z","comments":true,"path":"2019/10/29/iar-setting/","link":"","permalink":"https://zhangxiaocn.github.io/2019/10/29/iar-setting/","excerpt":"","text":"1、个性化配置 1.1、主题 效果如下： 点击 Tools -&gt; options 选择 Editor -&gt; Colors and Fonts 点击 Font，选择文字为 Consolas ，Size 选择 三号（按照自己的喜好设置大小） Syntax Coloring 一栏中设置如下： type Color（颜色） Type Style（类型风格） Background Color（背景颜色） Default White Normal Black C Keyword Lime Bold Black Strings Yellow Normal Black Char Aqua Normal Black Preprocessor Silver Normal Black Number Yellow Normal Black C++ Comment Aqua Italic Black comment Aqua Italic Black User Keyword Aqua Italic Black Compiler keyword Aqua Italic Black Asm keyword Fuchsia Bold Black Asm comment Lime Italic Black 1.2、设置代码缩进 点击 Tools -&gt; options 点击 Editor 将 Tab size 和 Indent size 后面的数字均改为 4（自定义即可） 1.3、关闭代码页面右边的竖线 点击 Tools -&gt; options 点击 Editor 将 Show right margin 前面的框取消勾选即可 1.4、修改默认字符格式为 UTF-8 点击 Tools -&gt; options 点击 Editor 将 Default character 下面框内的选项选为 UTF-8 1.5、显示行号 显示行号在 IAR 老版本上可能会出现一些 BUG，是由于主题的缘故。 点击 Tools -&gt; options 点击 Editor 勾选 Show line numbers 选项 2、软件使用问题 2.1、解决函数无法跳转问题 点击 Tools -&gt; options 选择 Project 关闭 Generate browse information ，点击确定 再次进入设置并重复以上步骤，把刚才关闭的 Generate browse information 选项打开，点击确定 在软件左侧 Workspace 中，右键第一个文件，点击 Rebuild All ，等待右下角绿色进度条走完 2.2、解决软件左侧 Workspace 消失问题 点击 View -&gt; Workspace即可 软件缺少任何视图都可以在 View 栏中找到并打开 2.3、用山外调试助手烧录 K60 程序错误问题 在软件左侧 Workspace 中找到 Files 里的第一个文件并右击鼠标，选择 Options 选择 General Options 中，把 Device 改为 NXP MK60FX512xxx15 选择 Debugger ，在 Setup 中把 Driver 改为 CMSIS DAP ，在 Download 中把框中的文字改为 $TOOLKIT_DIR$\\config\\flashloader\\NXP\\FlashK60Fxxx128K.board 选择 CMSIS DAP ，在 interface 栏中把 JTAG 改为 SWD","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://zhangxiaocn.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"IAR","slug":"IAR","permalink":"https://zhangxiaocn.github.io/tags/IAR/"},{"name":"开发软件","slug":"开发软件","permalink":"https://zhangxiaocn.github.io/tags/%E5%BC%80%E5%8F%91%E8%BD%AF%E4%BB%B6/"}]},{"title":"换电脑后快速恢复 hexo 博客","slug":"continue-blog","date":"2019-10-29T13:23:54.000Z","updated":"2020-01-08T15:15:08.573Z","comments":true,"path":"2019/10/29/continue-blog/","link":"","permalink":"https://zhangxiaocn.github.io/2019/10/29/continue-blog/","excerpt":"","text":"1、前言 使用 Github + hexo 搭建一个个人博客是需要花不少时间的，搭建好后如果有一天电脑突然坏了，或者重装了系统，那么我们怎么使用 hexo 再发布文章到个人博客呢？其实方法还是有的！ 2、操作方法 2.1、安装软件 安装 Git 客户端 安装 node JS：建议下载 LTS 长期支持版 2.2、在 github 官网添加新电脑的密钥 首先输入（yourname 和 youremail 改为你的名字和邮箱）： Code12git config --global user.name &quot;yourname&quot;git config --global user.email &quot;youremail&quot; 在本地创建 SSH Keys： Code1ssh-keygen -t rsa -C &quot;@邮箱&quot; 一路回车。 进入 C:\\Users\\用户名.ssh，打开 id_rsa.pub 文件，复制里面所有的内容，然后进入 github 页面，点击右上角的 头像 &gt; Settings ，在左侧找到 SSH and GPG keys。 点击 New SSH key ，Title 里的内容可以自定义，Key 里填入复制的内容。点击 add key。 返回窗口，输入： Code1ssh -T git@github.com 若弹出 Are you sure you want to continue connecting (yes/no)? 时输入 yes 确认。 接着出现 Hi xxx! You've successfully authenticated, but GitHub does not provide shell access. 则操作成功。 2.3、复制源文件到新电脑 将你原来电脑上个人博客目录下必要文件拷到你的新电脑上（比如 E:/Blog 目录下），注意无需拷全部，只拷如下几个目录（当然你要拷全部也可以）： _config.yml package.json scaffolds/ source/ themes/ 2.4、安装 Hexo 在命令行输入： Code1npm install hexo-cli -g 进入 E:/Blog 目录（新电脑的博客目录），输入下面指令安装相关模块： Code12345npm installnpm install hexo-deployer-git --save // 文章部署到 git 的模块（下面为选择安装）npm install hexo-generator-feed --save // 建立 RSS 订阅npm install hexo-generator-sitemap --save // 建立站点地图 2.5、测试是否成功 命令行输入： Code123hexo clean // 清除缓存 网页正常情况下可以忽略此条命令hexo g // 生成静态网页hexo s // 启动服务器 访问网址： http://localhost:4000/ 若能正常显示则成功。","categories":[{"name":"Blog","slug":"Blog","permalink":"https://zhangxiaocn.github.io/categories/Blog/"}],"tags":[{"name":"Blog","slug":"Blog","permalink":"https://zhangxiaocn.github.io/tags/Blog/"},{"name":"Hexo","slug":"Hexo","permalink":"https://zhangxiaocn.github.io/tags/Hexo/"}]},{"title":"Hexo NexT 主题的启用及设置","slug":"hexo-theme-next","date":"2019-10-29T13:05:08.000Z","updated":"2020-01-08T15:23:43.982Z","comments":true,"path":"2019/10/29/hexo-theme-next/","link":"","permalink":"https://zhangxiaocn.github.io/2019/10/29/hexo-theme-next/","excerpt":"","text":"1、主题的启用 1.1、下载并启用 进入命令行，下载 NexT 主题，输入： Code1git clone https://github.com/theme-next/hexo-theme-next themes/next 修改站点配置文件 _config.yml，找到如下代码： yml12## Themes: https://hexo.io/themes/theme: landscape 将 landscape 修改为 next 即可。 1.2、修改语言 打开站点配置文件，搜索 language，找到如下代码： yml123author:language:timezone: 在 language 后面输入 zh-CN。 注意：冒号后面必须有一个空格。 2、主题的设置 2.1、新建标签及分类界面 打开 主题配置文件，搜索 menu，找到如下代码： yml123456789menu: home: / || home #about: /about/ || user #tags: /tags/ || tags #categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat 把 tags 和 categories 前面的 # 删除，进入命令行，输入： Code12hexo n page tagshexo n page categories 进入博客主目录 Hexo/source，找到 tags 和 categories 文件夹，分别进入并修改文件夹内的文件。例如，先进入 tags 文件夹，打开 index.md 文件，在 date 下一行输入： markdown1type: \"tags\" 修改 categories 文件夹下的文件时，只需把上面的 tags 代码改成 categories 即可。 2.2、切换主题 next 主题自带四种样式。 在主题配置文件 /next/_config.yml 中查找：scheme，找到如下代码： yml12345# Schemesscheme: Muse#scheme: Mist#scheme: Pisces#scheme: Gemini 选择你喜欢的一种样式，去掉前面的 #，其他主题前加上 # 即可。 2.3、隐藏网页底部 powered By Hexo / 强力驱动 打开 themes/next/layout/_partials/footer.swig 找到： Code123456789101112131415161718&#123;% if theme.footer.powered.enable %&#125; &lt;div class=&quot;powered-by&quot;&gt;&#123;# #&#125;&#123;&#123; __(&apos;footer.powered&apos;, &apos;&lt;a class=&quot;theme-link&quot; target=&quot;_blank&quot;&apos; + nofollow + &apos; href=&quot;https://hexo.io&quot;&gt;Hexo&lt;/a&gt;&apos;) &#125;&#125;&#123;% if theme.footer.powered.version %&#125; v&#123;&#123; hexo_env(&apos;version&apos;) &#125;&#125;&#123;% endif %&#125;&#123;##&#125;&lt;/div&gt;&#123;% endif %&#125;&#123;% if theme.footer.powered.enable and theme.footer.theme.enable %&#125; &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;&#123;% endif %&#125;&#123;% if theme.footer.theme.enable %&#125; &lt;div class=&quot;theme-info&quot;&gt;&#123;# #&#125;&#123;&#123; __(&apos;footer.theme&apos;) &#125;&#125; – &#123;# #&#125;&lt;a class=&quot;theme-link&quot; target=&quot;_blank&quot;&#123;&#123; nofollow &#125;&#125; href=&quot;https://theme-next.org&quot;&gt;&#123;# #&#125;NexT.&#123;&#123; theme.scheme &#125;&#125;&#123;# #&#125;&lt;/a&gt;&#123;% if theme.footer.theme.version %&#125; v&#123;&#123; version &#125;&#125;&#123;% endif %&#125;&#123;##&#125;&lt;/div&gt;&#123;% endif %&#125; 把这段代码首尾分别加上：&lt;!-- 和 --&gt;，或者直接删除。 2.4、文章添加阴影 打开 /themes/next/source/css/_custom/custom.styl，添加： stylus1234567.post &#123; margin-top: 60px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5); &#125; 2.5、浏览页面显示当前浏览进度 打开 themes/next/_config.yml，搜索关键字 scrollpercent，把 false 改为 true。 2.6、Local Search本地搜索 在站点的根目录下执行以下命令： Code1npm install hexo-generator-searchdb --save 编辑站点配置文件，新增以下内容到任意位置： yml12345search: path: search.xml field: post format: html limit: 10000 编辑主题配置文件，启用本地搜索功能： yml123# Local searchlocal_search: enable: true 2.7、设置个人头像 打开 主题配置文件，找到 Sidebar Avatar 字段： yml123456789101112# Sidebar Avataravatar: # in theme directory(source/images): /images/avatar.gif # in site directory(source/uploads): /uploads/avatar.gif # You can also use other linking images. url: #/images/avatar.jpg # If true, the avatar would be dispalyed in circle. rounded: false # The value of opacity should be choose from 0 to 1 to set the opacity of the avatar. opacity: 1 # If true, the avatar would be rotated with the cursor. rotated: false 将 url 后面的 # 删掉，然后把你的头像命名为 avatar.jpg 放入 themes/next/source/images 中 rounded ：设置头像为圆形 opacity ：设置头像的不透明度 rotated ：设置头像可旋转 2.8、设置站点建立时间 在 主题配置文件 中，搜索：since，修改 since 后面的值即可，例如： yml1since: 2013 2.9、设置网站图标 在 EasyIcon 中找一张（32*32）的 ico 图标，或者去别的网站下载或者制作，并将图标名称改为favicon.ico，然后把图标放在 /themes/next/source/images 里，并且修改主题配置文件： yml12# Put your favicon.ico into `hexo-site/source/` directory.favicon: /favicon.ico 2.10、修改文章底部的 # 号的标签 修改模板 /themes/next/layout/_macro/post.swig 搜索 rel=&quot;tag&quot;&gt;#，将 # 换成 &lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt; 2.11、网站底部字数统计 切换到根目录下，运行如下代码： Code1npm install hexo-wordcount --save 然后在 /themes/next/layout/_partials/footer.swig 文件尾部加上： Code1234&lt;div class=&quot;theme-info&quot;&gt; &lt;div class=&quot;powered-by&quot;&gt;&lt;/div&gt; &lt;span class=&quot;post-count&quot;&gt;博客全站共&#123;&#123; totalcount(site) &#125;&#125;字&lt;/span&gt;&lt;/div&gt; 2.12、添加点击爱心效果 在 /themes/next/source/js/src 下新建文件 clicklove.js，接着把如下代码复制粘贴到 clicklove.js 文件中，代码如下： Javascript1!function(e,t,a)&#123;function n()&#123;c(\".heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;\"),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText=\"left:\"+d[e].x+\"px;top:\"+d[e].y+\"px;opacity:\"+d[e].alpha+\";transform:scale(\"+d[e].scale+\",\"+d[e].scale+\") rotate(45deg);background:\"+d[e].color+\";z-index:99999\");requestAnimationFrame(r)&#125;function o()&#123;var t=\"function\"==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement(\"div\");a.className=\"heart\",d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement(\"style\");a.type=\"text/css\";try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName(\"head\")[0].appendChild(a)&#125;function s()&#123;return\"rgb(\"+~~(255*Math.random())+\",\"+~~(255*Math.random())+\",\"+~~(255*Math.random())+\")\"&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document); 在 \\themes\\next\\layout\\_layout.swig 文件末尾添加： Code12&lt;!-- 页面点击小红心 --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/clicklove.js&quot;&gt;&lt;/script&gt; 2.13、点击爆炸效果 方法和那个点击出现爱心效果是差不多的，首先在 themes/next/source/js/src 里面建一个叫 fireworks.js 的文件，代码如下： Javascript1\"use strict\";function updateCoords(e)&#123;pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top&#125;function setParticuleDirection(e)&#123;var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return&#123;x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)&#125;&#125;function createParticule(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function()&#123;ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()&#125;,a&#125;function createCircle(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color=\"#F00\",a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function()&#123;ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1&#125;,a&#125;function renderParticule(e)&#123;for(var t=0;t&lt;e.animatables.length;t++)&#123;e.animatables[t].target.draw()&#125;&#125;function animateParticules(e,t)&#123;for(var a=createCircle(e,t),n=[],i=0;i&lt;numberOfParticules;i++)&#123;n.push(createParticule(e,t))&#125;anime.timeline().add(&#123;targets:n,x:function(e)&#123;return e.endPos.x&#125;,y:function(e)&#123;return e.endPos.y&#125;,radius:0.1,duration:anime.random(1200,1800),easing:\"easeOutExpo\",update:renderParticule&#125;).add(&#123;targets:a,radius:anime.random(80,160),lineWidth:0,alpha:&#123;value:0,easing:\"linear\",duration:anime.random(600,800)&#125;,duration:anime.random(1200,1800),easing:\"easeOutExpo\",update:renderParticule,offset:0&#125;)&#125;function debounce(e,t)&#123;var a;return function()&#123;var n=this,i=arguments;clearTimeout(a),a=setTimeout(function()&#123;e.apply(n,i)&#125;,t)&#125;&#125;var canvasEl=document.querySelector(\".fireworks\");if(canvasEl)&#123;var ctx=canvasEl.getContext(\"2d\"),numberOfParticules=30,pointerX=0,pointerY=0,tap=\"mousedown\",colors=[\"#FF1461\",\"#18FF92\",\"#5A87FF\",\"#FBF38C\"],setCanvasSize=debounce(function()&#123;canvasEl.width=2*window.innerWidth,canvasEl.height=2*window.innerHeight,canvasEl.style.width=window.innerWidth+\"px\",canvasEl.style.height=window.innerHeight+\"px\",canvasEl.getContext(\"2d\").scale(2,2)&#125;,500),render=anime(&#123;duration:1/0,update:function()&#123;ctx.clearRect(0,0,canvasEl.width,canvasEl.height)&#125;&#125;);document.addEventListener(tap,function(e)&#123;\"sidebar\"!==e.target.id&amp;&amp;\"toggle-sidebar\"!==e.target.id&amp;&amp;\"A\"!==e.target.nodeName&amp;&amp;\"IMG\"!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))&#125;,!1),setCanvasSize(),window.addEventListener(\"resize\",setCanvasSize,!1)&#125;\"use strict\";function updateCoords(e)&#123;pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top&#125;function setParticuleDirection(e)&#123;var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return&#123;x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)&#125;&#125;function createParticule(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function()&#123;ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()&#125;,a&#125;function createCircle(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color=\"#F00\",a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function()&#123;ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1&#125;,a&#125;function renderParticule(e)&#123;for(var t=0;t&lt;e.animatables.length;t++)&#123;e.animatables[t].target.draw()&#125;&#125;function animateParticules(e,t)&#123;for(var a=createCircle(e,t),n=[],i=0;i&lt;numberOfParticules;i++)&#123;n.push(createParticule(e,t))&#125;anime.timeline().add(&#123;targets:n,x:function(e)&#123;return e.endPos.x&#125;,y:function(e)&#123;return e.endPos.y&#125;,radius:0.1,duration:anime.random(1200,1800),easing:\"easeOutExpo\",update:renderParticule&#125;).add(&#123;targets:a,radius:anime.random(80,160),lineWidth:0,alpha:&#123;value:0,easing:\"linear\",duration:anime.random(600,800)&#125;,duration:anime.random(1200,1800),easing:\"easeOutExpo\",update:renderParticule,offset:0&#125;)&#125;function debounce(e,t)&#123;var a;return function()&#123;var n=this,i=arguments;clearTimeout(a),a=setTimeout(function()&#123;e.apply(n,i)&#125;,t)&#125;&#125;var canvasEl=document.querySelector(\".fireworks\");if(canvasEl)&#123;var ctx=canvasEl.getContext(\"2d\"),numberOfParticules=30,pointerX=0,pointerY=0,tap=\"mousedown\",colors=[\"#FF1461\",\"#18FF92\",\"#5A87FF\",\"#FBF38C\"],setCanvasSize=debounce(function()&#123;canvasEl.width=2*window.innerWidth,canvasEl.height=2*window.innerHeight,canvasEl.style.width=window.innerWidth+\"px\",canvasEl.style.height=window.innerHeight+\"px\",canvasEl.getContext(\"2d\").scale(2,2)&#125;,500),render=anime(&#123;duration:1/0,update:function()&#123;ctx.clearRect(0,0,canvasEl.width,canvasEl.height)&#125;&#125;);document.addEventListener(tap,function(e)&#123;\"sidebar\"!==e.target.id&amp;&amp;\"toggle-sidebar\"!==e.target.id&amp;&amp;\"A\"!==e.target.nodeName&amp;&amp;\"IMG\"!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))&#125;,!1),setCanvasSize(),window.addEventListener(\"resize\",setCanvasSize,!1)&#125;; 打开 themes/next/layout/_layout.swig，在 &lt;/body&gt; 上面写下如下代码： Code12345&#123;% if theme.fireworks %&#125; &lt;canvas class=&quot;fireworks&quot; style=&quot;position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;&quot; &gt;&lt;/canvas&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;//cdn.bootcss.com/animejs/2.2.0/anime.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/fireworks.js&quot;&gt;&lt;/script&gt;&#123;% endif %&#125; 打开主题配置文件，在里面最后写下： yml12# Fireworksfireworks: true 2.14、动态背景 2.14.1、next 主题在 5.1.1 以上 打开 next/layout/_layout.swig文件 在 &lt;/body&gt; 之前添加如下代码，不要放在 &lt;/head&gt; 的后面： html1234&#123;% if theme.canvas_nest %&#125;&lt;script type=\"text/javascript\"color=\"0,0,255\" opacity='0.7' zIndex=\"-2\" count=\"99\" src=\"//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js\"&gt;&lt;/script&gt;&#123;% endif %&#125; 打开主题配置文件 /next/_config.yml 搜素 canvas_nest，将 false 改为 true 即可。 2.14.2、next 主题在 5.1.1 以下 打开 next/layout/_layout.swig 文件 在 &lt;/body&gt; 之前添加如下代码，不要放在 &lt;/head&gt; 的后面： html1234&#123;% if theme.canvas_nest %&#125;&lt;script type=\"text/javascript\"color=\"0,0,255\" opacity='0.7' zIndex=\"-2\" count=\"99\" src=\"//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js\"&gt;&lt;/script&gt;&#123;% endif %&#125; 打开主题配置文件 /next/_config.yml 在里面添加如下代码：(可以放在最后面) yml123456# --------------------------------------------------------------# background settings# --------------------------------------------------------------# add canvas-nest effect# see detail from https://github.com/hustcc/canvas-nest.jscanvas_nest: true 2.14.3、配置项说明 color：线条颜色, 默认: ‘0,0,0’；三个数字分别为 (R,G,B) opacity: 线条透明度（0~1）, 默认: 0.5 count: 线条的总数量, 默认: 150 zIndex: 背景的 z-index 属性，css 属性用于控制所在层的位置, 默认: -1 2.15、修改文章不透明度 设置了动态背景后，动态线条会干扰到文章的阅读，所以就需要调整文章背景的不透明度了。 修改 themes\\next\\source\\css\\ _custom\\custom.styl 文件，在后面添加如下代码： stylus1234567.main-inner &#123; margin-top: 60px; padding: 60px 60px 60px 60px; background: #fff; opacity: 0.8; min-height: 500px;&#125; 2.15.1、配置项说明 background: #fff; 白色 opacity: 0.8; 不透明度 2.16、自动更换背景图片 和修改动态背景类似。 自动更换背景是修改添加背景的 css 样式来实现。图片来源是： Code1https://source.unsplash.com/ 这个网站不仅免费提供了很多高清美图，而且还提供 api 接口调用，非常良心。这里实现的原理也是调用了这个网站的接口。 修改 themes\\next\\source\\css\\ _custom\\custom.styl 文件，添加以下代码： stylus123456body &#123; background:url(https://source.unsplash.com/random/1600x900); background-repeat: no-repeat; background-attachment:fixed; background-position:50% 50%;&#125; 如果不喜欢这个网址提供的图片做背景，可以修改url()里面的路径。repeat、attachment、position就是调整图片的位置、不重复出现、不滚动等等。 2.17、静态背景 打开博客根目录 /themes/next/source/css/_custom/custom.styl 文件，编辑如下： stylus1234567// Custom styles.body &#123; background-image: url(/images/background.png); background-attachment: fixed; // 不随屏幕滚动而滚动 background-repeat: repeat; // 如果背景图不够屏幕大小则重复铺，改为no-repeat则表示不重复铺 background-size: contain; // 等比例铺满屏幕&#125; 然后将背景图命名为 background.png 并放入主题根目录 source/images 下。 2.18、修改主题颜色 找到 博客根目录\\themes\\next\\source\\css\\_custom\\custom.styl 并打开 如下列出了蓝色主题的参考代码，可以直接使用： stylus12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273// 文章内链接文本样式 .post-body p a&#123; color: #0593d3; border-bottom: none; border-bottom: 1px solid #0593d3; &amp;:hover &#123; color: #fc6423; border-bottom: none; border-bottom: 1px solid #fc6423; &#125; &#125;// 修改选中字符的颜色/* webkit, opera, IE9 */::selection &#123; background: #49b1f5; color: #fff; &#125;/* firefox */::-moz-selection &#123; background: #49b1f5; color: #fff; &#125;// 修改网站头部颜色.headband &#123; height: 3px; background: #49b1f5;&#125;.site-meta &#123; padding: 20px 0; color: #fff; background: #49b1f5;&#125;.site-subtitle &#123; margin-top: 10px; font-size: 13px; color: #ffffff;&#125;// 修改按键（button）样式.btn &#123; color: #49b1f5; background: #fff; border: 2px solid #49b1f5;&#125;// 按键（button）点击时样式.btn:hover &#123; border-color: #49b1f5; color: #fff; background: #49b1f5;&#125;// 鼠标移动至文章标题时的效果.posts-expand .post-title-link::before &#123; content: \"\"; position: absolute; width: 100%; height: 2px; bottom: 0; left: 0; background-color: #49b1f5; visibility: hidden; -webkit-transform: scaleX(0); -moz-transform: scaleX(0); -ms-transform: scaleX(0); -o-transform: scaleX(0); transform: scaleX(0); transition-duration: 0.2s; transition-timing-function: ease-in-out; transition-delay: 0s;&#125;","categories":[{"name":"Blog","slug":"Blog","permalink":"https://zhangxiaocn.github.io/categories/Blog/"}],"tags":[{"name":"Blog","slug":"Blog","permalink":"https://zhangxiaocn.github.io/tags/Blog/"},{"name":"Hexo","slug":"Hexo","permalink":"https://zhangxiaocn.github.io/tags/Hexo/"},{"name":"美化","slug":"美化","permalink":"https://zhangxiaocn.github.io/tags/%E7%BE%8E%E5%8C%96/"}]},{"title":"我初学 C 的代码保留","slug":"my-c-memory","date":"2019-10-27T13:23:55.000Z","updated":"2019-10-29T13:26:24.407Z","comments":true,"path":"2019/10/27/my-c-memory/","link":"","permalink":"https://zhangxiaocn.github.io/2019/10/27/my-c-memory/","excerpt":"","text":"以下内容为本人初学 C 的时候所写的部分代码，有些程序现在看起来写的真的很烂哈哈，但是舍不得删除呐，最后还是将它们保留了下来。。。这算不算是松鼠症？？ 求和问题 求 1 + 2! + 3! + … + 20! 的和： c123456789int sum(void) &#123; float a = 1, b = 0, i; for (i = 1; i &lt;= 20; i++) &#123; a = a * i; b = b + a; &#125; printf(\"1 + 2! + 3! ... + 20! = %.0f\\n\", b); return 0;&#125; 求 1 + 2 + … + 100 的和： c123456789101112int sum(void) &#123; int a, b = 0; a = 1;loop: if (a &lt;= 100) &#123; b = b + a; a++; goto loop; &#125; printf(\"1 + 2 + ... + 100 的和为：%d\\n\", b); return 0;&#125; 有一分数序列：2/1，3/2，5/3，8/5，13/8，21/13 … 求出这个数列的前 20 项之和： c123456789101112int sum(void) &#123; int i; float a = 2, b = 1, c = 0, d; for (i = 1; i &lt;= 20; i++) &#123; c = a / b + c; d = a; a = a + b; b = d; &#125; printf(\"这个数列的前20项之和为：%f\\n\", c); return 0;&#125; 求序列 S = 2/1 + 3/2 + 5/3 + 8/5 + 13/8 + …… 前 n 项和： c123456789101112131415int sum(void) &#123; float S = 0, s1 = 2, s2 = 1; int a, n; printf(\"请输入 n 的值：\"); scanf(\"%d\", &amp;n); for (a = 0; a &lt; n; a++) &#123; S = (s1 / s2) + S; s2 = s1; s1 = (2 * s1) - 1; &#125; printf(\"S = 2/1 + 3/2 + 5/3 + 8/5 + 13/8 + …… 前 n 项和为：%f\", S); printf(\"\\n\"); return 0;&#125; 求 1 到 100 之间的奇数之和，偶数之和： c123456789101112int sum(void) &#123; int i, sum1 = 0, sum2 = 0; for (i = 1; i &lt;= 100; i++) &#123; if (i % 2 != 0) sum1 += i; else sum2 += i; &#125; printf(\"1~100 的奇数和为：%d\\n\", sum1); printf(\"1~100 的偶数和为：%d\\n\", sum2); return 0;&#125; 阶乘问题 求 n 的阶乘 n!： c1234567891011int factorial(void) &#123; int i = 1, s = 1, n; printf(\"请输入需要求阶乘的数字：\"); scanf(\"%d\", &amp;n); do &#123; s = s * i; i++; &#125; while (i &lt;= n); printf(\"%d! = %d\\n\", n, s); return 0;&#125; c12345678int factorial(void) &#123; int i, s, n; printf(\"请输入需要求阶乘的数字：\"); scanf(\"%d\", &amp;n); for (i = 1, s = 1; i &lt;= n; i++) s = s * i; printf(\"%d! = %d\\n\", n, s); return 0;&#125; c1234567891011int factorial(void) &#123; int i = 1, s = 1, n; printf(\"请输入需要求阶乘的数字：\"); scanf(\"%d\", &amp;n); while (i &lt;= n) &#123; // 一直算到 i &gt; n 时循环结束，输出 s = s * i; i++; &#125; printf(\"%d! = %d\\n\", n, s); return 0;&#125; 素数问题 判断输入的数字是否为素数： c1234567891011121314151617int prime_number(void) &#123; int a = 0, i; int n = 0; printf(\"输入一个整数：\"); scanf(\"%d\", &amp;n); for (i = 2; i &lt; n; i++) &#123; if (n % i == 0) &#123; a++; &#125; &#125; if (a == 0) &#123; printf(\"%d 是素数\\n\", n); &#125; else &#123; printf(\"%d 不是素数\\n\", n); &#125; return 0;&#125; 求出 100~200 之间的所有素数： c1234567891011121314151617int prime_number(void) &#123; int m, i, a = 0, b = 0; printf(\"\\n\"); printf(\"100~200 之间的所有素数为：\"); for (m = 101; m &lt;= 200; m++) &#123; for (i = 2; i &lt; m; i++) &#123; if (m % i == 0) a++; &#125; if (a == 0) &#123; printf(\"%-4d\", m); b++; &#125; else a = 0; &#125; printf(\"\\n这些素数一共有 %d 个\", b); return 0;&#125; 求 100~300 之间所有素数之和： c1234567891011121314151617181920int prime_number(void) &#123; int m, i, a = 0, b = 0, c, d = 0; printf(\"\\n\"); printf(\"100 ~ 300之间所有素数之和为：\"); for (m = 101; m &lt;= 300; m++) &#123; for (i = 2; i &lt; m; i++) &#123; if (m % i == 0) a++; &#125; if (a == 0) &#123; c = m; d = c + d; &#125; else a = 0; &#125; printf(\"%d\", d); printf(\"\\n\"); return 0;&#125; 编写一个程序，从键盘输入一个整数，输出大于且紧随该整数的素数： c1234567891011121314151617181920int prime_number(void) &#123; int a = 0, i, n, m; printf(\"输入一个整数：\"); scanf(\"%d\", &amp;n); m = n + 1;A: for (i = 2; i &lt; m; i++) &#123; if (m % i == 0) &#123; a++; &#125; &#125; if (a == 0) &#123; printf(\"大于且最接近输入的数的素数是：%d\\n\", m); &#125; else &#123; m = m + 1; a = 0; goto A; &#125; return 0;&#125; c1234567891011121314151617int prime_number(void) &#123; int i, m, c; scanf(\"%d\", &amp;m); while (1) &#123; m++; c = 1; for (i = 2; i &lt; m; i++) &#123; if (m % i == 0) &#123; c = 0; break; &#125; &#125; if (c == 1) break; &#125; printf(\"%d\\n\", m); return 0;&#125; 排序问题 从键盘输入 10 个整数，编程求出其中的最大值和最小值，并输出结果： c1234567891011121314int sort(void) &#123; int max, min, m[10], i; printf(\"请输出10个数：\"); for (i = 0; i &lt; 10; i++) scanf(\"%d\", &amp;m[i]); // 输入 10 个数字，保存到 m[i] 中 max = min = m[0]; // 定义最值 for (i = 1; i &lt; 10; i++) if (max &lt; m[i]) // m[i] 依次与最值比较，得出最大值 max max = m[i]; else if (min &gt; m[i]) // m[i] 依次与最值比较，得出最小值 min min = m[i]; printf(\"最大值 = %d\\n最小值 = %d\", max, min); return 0;&#125; 将输入的五个整数按照从小到大顺序排列： c12345678910111213141516171819int sort(void) &#123; int a[5]; int i, j, t; printf(\"请输入5个数：\"); for (i = 0; i &lt; 5; i++) scanf(\"%d\", &amp;a[i]); printf(\"\\n\"); for (j = 0; j &lt; 4; j++) // 进行 4 次循环，实现 4 趟比较 for (i = 0; i &lt; 4 - j; i++) // 在每一趟比较中进行 4－1 次比较 if (a[i] &gt; a[i + 1]) // 相邻两个数比较 &#123; t = a[i]; a[i] = a[i + 1]; a[i + 1] = t; &#125; printf(\"排序后的数据为：\"); for (i = 0; i &lt; 5; i++) printf(\"%d \", a[i]); printf(\"\\n\"); return 0;&#125; 输出图像 输出一个菱形： c1234567891011121314int diamond(void) &#123; int a, b, c; for (a = 0; a &lt; 4; a++) &#123; for (b = 0; b &lt;= 2 - a; b++) printf(\" \"); for (c = 0; c &lt;= 2 * a; c++) printf(\"*\"); printf(\"\\n\"); &#125; for (a = 0; a &lt;= 2; a++) &#123; for (b = 0; b &lt;= a; b++) printf(\" \"); for (c = 0; c &lt;= 4 - 2 * a; c++) printf(\"*\"); printf(\"\\n\"); &#125; return 0;&#125; 输出一个行数可调的菱形： c12345678910int diamond(void) &#123; int n, i, j; scanf(\"%d\", &amp;n); // 输入一个 n，则输出 2*n+1 行 for (i = -n; i &lt;= n; i++) &#123; for (j = 1; j &lt;= abs(i); j++) printf(\" \"); for (j = 1; j &lt;= 2 * n + 1 - 2 * abs(i); j++) printf(\"*\"); printf(\"\\n\"); &#125; return 0;&#125; 输出空心菱形： c12345678910111213141516171819202122232425262728293031323334353637int diamond(void) &#123; int i, j, k, line, m; printf(\"请输入行数：\"); scanf(\"%d\", &amp;line); m = (line + 1) / 2; for (i = 1; i &lt;= m; i++) &#123; for (k = 0; k &lt; m - i; k++) &#123; printf(\" \"); &#125; printf(\"*\"); if (i == 1) &#123; printf(\"\\n\"); continue; &#125; for (j = 0; j &lt; 2 * i - 3; j++) &#123; printf(\" \"); &#125; printf(\"*\"); printf(\"\\n\"); &#125; for (i = m - 1; i &gt; 0; i--) &#123; for (k = 0; k &lt; m - i; k++) &#123; printf(\" \"); &#125; printf(\"*\"); if (i == 1) &#123; printf(\"\\n\"); continue; &#125; for (j = 0; j &lt; 2 * i - 3; j++) &#123; printf(\" \"); &#125; printf(\"*\"); printf(\"\\n\"); &#125; return 0;&#125; 输出一个正方形中的空心菱形（行数可控）： c123456789101112131415161718192021int diamond(void) &#123; int n, i, j; printf(\"请输入这个空心菱形的行数：\"); scanf(\"%d\", &amp;n); printf(\"\\n\"); for (i = -(n / 2); i &lt;= n / 2; i++) &#123; if (i == -(n / 2) || i == (n / 2)) &#123; //第一行和最后一行 for (j = 1; j &lt;= n; j++) &#123; printf(\"*\"); &#125; printf(\"\\n\"); &#125; else &#123; for (j = 1; j &lt;= abs(i) + 1; j++) printf(\"*\"); for (j = 1; j &lt;= (n - 2 * (abs(i) + 1)); j++) printf(\" \"); for (j = 1; j &lt;= abs(i) + 1; j++) printf(\"*\"); printf(\"\\n\"); &#125; &#125; printf(\"\\n\"); return 0;&#125; 文字玩法 输入一个 5 位数，判断它是不是回文数： c1234567891011121314151617181920int palindrome(void) &#123; int x; // 带输入的数 int g, w, s, q; // 分别表示的是个位、万位、十位、千位 printf(\"请输入一个 5 位数：\"); scanf(\"%d\", &amp;x); if (x &gt; 99999 || x &lt; 10000) printf(\"您输入的 %d 不是一个 5 位数\\n\", x); else &#123; g = x % 10; w = x / 10000; s = (x % 100) / 10; q = (x % 10000) / 1000; if (g == w &amp;&amp; s == q) printf(\"%d 是一个回文数\\n\", x); else printf(\"%d 不是一个回文数\\n\", x); &#125; return 0;&#125; 输出 9×9 口诀表： c123456789101112int table(void) &#123; int i, j, result; printf(\"\\n\"); for (i = 1; i &lt; 10; i++) &#123; for (j = 1; j &lt; 10; j++) &#123; result = i * j; printf(\"%d*%d=%-3d\", i, j, result); // -3d 表示左对齐，占 3 位 &#125; printf(\"\\n\"); // 每一行后换行 &#125; return 0;&#125;","categories":[{"name":"C","slug":"C","permalink":"https://zhangxiaocn.github.io/categories/C/"}],"tags":[{"name":"回忆","slug":"回忆","permalink":"https://zhangxiaocn.github.io/tags/%E5%9B%9E%E5%BF%86/"},{"name":"C","slug":"C","permalink":"https://zhangxiaocn.github.io/tags/C/"}]},{"title":"Hexo yilia 主题的启用及设置","slug":"hexo-theme-yilia","date":"2019-10-25T13:57:17.000Z","updated":"2020-01-08T15:25:18.678Z","comments":true,"path":"2019/10/25/hexo-theme-yilia/","link":"","permalink":"https://zhangxiaocn.github.io/2019/10/25/hexo-theme-yilia/","excerpt":"","text":"yilia 主题作者已经不维护了，还有好多坑没有填完，在此记录一下 主题地址：https://github.com/litten/hexo-theme-yilia 本文章同步更新地址：https://www.cnblogs.com/zhangxiaochn/p/Hexo_Theme_Yilia.html 1、主题的启用 1.1、下载并启用 进入命令行，下载 yilia 主题，输入： Code1git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 修改站点配置文件 _config.yml，找到如下代码： yml12## Themes: https://hexo.io/themes/theme: landscape 将 landscape 修改为 yilia 即可。 1.2、修改语言 打开站点配置文件，搜索language，找到如下代码： yml123author:language:timezone: 在 language 后面输入 zh-CN。 注意：冒号后面必须有一个空格。 2、主题相关设置 2.1、“所有文章”按钮的安装 首先使用命令 node -v 检查版本是不是大于 6.2 在博客根目录执行以下命令： Code1npm i hexo-generator-json-content --save 在博客配置文件 _config.yml 最下面加上： yml123456789101112131415161718jsonContent: meta: false pages: false posts: title: true date: true path: true text: false raw: false content: false slug: false updated: false comments: false link: false permalink: false excerpt: false categories: false tags: true 2.2、添加图片资源文件夹 路径为 themes/yilia/source/ 下，可添加一个 assets 文件夹，里面存放图片资源即可 需要添加头像或者微信/支付宝二维码图片，直接引用即可。路径为 themes/yilia/_config.yml 。 yml12345678# 微信二维码图片weixin: /assets/img/wechat.png# 头像图片avatar: /assets/img/head.jpg# 网页图标favicon: /assets/img/head.jpg 2.3、文章显示摘要 在你 MD 格式文章正文插入 &lt;!-- more --&gt; 即可，只会显示它之前的，此后的就不显示，点击文章标题，全文阅读才可看到，同时注释掉文件 themes/yilia/_config.yml 里的： yml1# excerpt_link: more 2.4、文章显示目录 增加文章目录 TOC ( table of content )，方便阅读文章，在 themes/yilia/_config.yml 中进行配置 toc: 2 即可，它会将你 Markdown 语法的标题，生成目录，目录查看在右下角。 2.5、增加归档菜单 修改 themes/yilia/_config.yml 内容： yml123menu: 主页: / 归档: /archives/index.html 2.6、修复失效的微信分享二维码 打开 themes\\yilia\\layout\\_partial\\post\\share.ejs 文件 把第49行中的 //pan.baidu.com/share/qrcode?url= 修改为： Code1//api.qrserver.com/v1/create-qr-code/?size=150x150&amp;data= 2.7、更改左侧昵称字体 在 themes\\yilia\\source\\main.0cf68a.css 文件里面修改，找到 header-author ，修改里面的 font-family ，改成： css1font-family:\"Times New Roman\",Georgia,Serif 2.8、左侧显示总文章数 打开 themes\\yilia\\layout\\_partial\\left-col.ejs 文件 在： Code1234567&lt;nav class=&quot;header-menu&quot;&gt; &lt;ul&gt; &lt;% for (var i in theme.menu)&#123; %&gt; &lt;li&gt;&lt;a href=&quot;&lt;%- url_for(theme.menu[i]) %&gt;&quot;&gt;&lt;%= i %&gt;&lt;/a&gt;&lt;/li&gt; &lt;%&#125;%&gt; &lt;/ul&gt;&lt;/nav&gt; 后面添加： Code123&lt;nav&gt; 总文章数 &lt;%=site.posts.length%&gt;&lt;/nav&gt; 2.9、添加字数统计 首先安装 hexo-wordcount 使用如下命令安装： Code1npm i --save hexo-wordcount Node 版本7.6.0之前,请安装 2.x 版本 (Node.js v7.6.0 and previous) Code1npm install hexo-wordcount@2 --save 然后在 themes\\yilia\\layout\\_partial\\left-col.ejs中添加： Code123&lt;nav&gt; 总字数 &lt;span class=&quot;post-count&quot;&gt;&lt;%= totalcount(site, &apos;0,0.0a&apos;) %&gt;&lt;/span&gt;&lt;/nav&gt; 添加位置在如下代码的下面： Code123&lt;nav&gt; 总文章数 &lt;%=site.posts.length%&gt;&lt;/nav&gt; 编辑 themes\\yilia\\layout\\_partial\\article.ejs 在header下面加入： Code123&lt;div align=&quot;center&quot; class=&quot;post-count&quot;&gt; 字数：&lt;%= wordcount(post.content) %&gt;字 | 预计阅读时长：&lt;%= min2read(post.content) %&gt;分钟&lt;/div&gt; 即可显示单篇字数和预计阅读时长。 2.10、添加来必力(livere)评论系统 yilia 默认带了几个系统，但是没有来必力，所以可以自己加 首先是去注册来必力，然后获取到自己的 id 新建 themes\\yilia\\layout\\_partial\\comment\\livere.ejs 文件，输入如下内容： Code123456789101112131415161718&lt;!-- 来必力City版安装代码 --&gt;&lt;div id=&quot;lv-container&quot; data-id=&quot;city&quot; data-uid=&quot;&lt;%=theme.livere_uid%&gt;&quot;&gt;&lt;script type=&quot;text/javascript&quot;&gt; (function(d, s) &#123; var j, e = d.getElementsByTagName(s)[0]; if (typeof LivereTower === &apos;function&apos;) &#123; return; &#125; j = d.createElement(s); j.src = &apos;https://cdn-city.livere.com/js/embed.dist.js&apos;; j.async = true; e.parentNode.insertBefore(j, e); &#125;)(document, &apos;script&apos;);&lt;/script&gt;&lt;noscript&gt;为正常使用来必力评论功能请激活JavaScript&lt;/noscript&gt;&lt;/div&gt;&lt;!-- City版安装代码已完成 --&gt; 然后编辑 themes\\yilia\\layout\\_partial\\article.ejs 文件，找到：&lt;% if (!index &amp;&amp; post.comments){ %&gt; ，添加： Code1234567&lt;% if (theme.livere)&#123; %&gt;&lt;%- partial(&apos;comment/livere&apos;, &#123;key: post.slug,title: post.title,url: config.url+url_for(post.path)&#125;) %&gt;&lt;% &#125; %&gt; 在主题配置文件 themes\\yilia\\_config.yml 中添加以下内容： yml12livere: truelivere_uid: 你的id 2.11、关闭信息收集（自选） 关于访问 litten.me:9005 的问题，这个主题的作者之前为了更好地完善这个主题，有时候会收集用户的客户端信息，详情请见 https://github.com/litten/hexo-theme-yilia/issues/528 ，如果不想被统计，就将 themes\\yilia\\source-src\\js\\report.js 里面的内容清空。不过这个请求是异步的，不会影响博客加载速度，而且作者已经不维护了，所以关不关都行。","categories":[{"name":"Blog","slug":"Blog","permalink":"https://zhangxiaocn.github.io/categories/Blog/"}],"tags":[{"name":"Blog","slug":"Blog","permalink":"https://zhangxiaocn.github.io/tags/Blog/"},{"name":"Hexo","slug":"Hexo","permalink":"https://zhangxiaocn.github.io/tags/Hexo/"},{"name":"美化","slug":"美化","permalink":"https://zhangxiaocn.github.io/tags/%E7%BE%8E%E5%8C%96/"}]},{"title":"Hexo+Github 创建个人博客","slug":"create-blog","date":"2019-10-25T11:54:41.000Z","updated":"2020-01-08T15:16:28.691Z","comments":true,"path":"2019/10/25/create-blog/","link":"","permalink":"https://zhangxiaocn.github.io/2019/10/25/create-blog/","excerpt":"","text":"1、安装及配置 首先安装如下软件，安装过程无脑点击下一步即可。 Git Node.js：建议下载 LTS 长期支持版 安装完成后，在 cmd 里输入 git version 即可查看 git 当前版本。输入 node -v 即可查看 node.js 当前版本。 接下来，新建一个文件夹，创建的位置任选。该文件夹主要用来存放博客的所有文件。然后进入该文件夹（这里就是博客文件夹的根目录，后文很多地方会用到），右键选择 Git Bash Here 选项。 在弹出的窗口中，输入 npm config set registry https://registry.npm.taobao.org 切换为淘宝源，从而加快下载速度。 接着，输入 npm i -g hexo 安装 hexo。 安装完成后，在当前窗口中，输入 hexo -v 即可查看 hexo 当前版本。 然后，我们输入命令 hexo init，初始化 hexo ，完成后打开我们的博客文件夹，即可看到该文件夹里有很多的文件了，这些都是我们搭建博客所需要的文件。 2、github 配置 首先进入 github 官网，注册新账号，账号名称一定要想好了再填，不然你会后悔的。。。 注册成功后点击右上角的 New repository，在 Reposotory name 栏中填入 yourname.github.io （yourname 改为你账号的名称），然后点击 Create reposutory。 接着我们回到博客文件夹的根目录，右键选择 Git Bash Here 选项，配置 github 账户的信息，输入： Code12git config --global user.name &quot;yourname&quot;git config --global user.email &quot;youremail&quot; 命令中的 yourname 和 youremail 分别改为你的账户名以及你创建该账户的邮箱。 然后输入cd ~/.ssh 检查电脑中的 SSH Key，会出现提示： No such file or directory 。 接下来我们开始创建 SSH。回到博客文件夹的根目录，右键选择 Git Bash Here 选项，输入 ssh-keygen -t rsa -C &quot;youremail@example.com，将 youremail@example.com 改为你的账户邮箱。一路回车即可。 紧接着输入： Code12cd ~/.sshcat id_rsa.pub 将获取的 ssh 复制下来，打开 github 首页，点击页面右上角的头像，选择 Settings，在下面的选项中找到 SSH and GPG keys 。点击 New SSH key ，Title 里的内容可以自定义，Key 里粘贴刚才复制的内容。点击 add key。 返回到博客文件夹的根目录，右键选择 Git Bash Here 选项，输入 ssh -T git@github.com 。 若弹出 Are you sure you want to continue connecting (yes/no)? 时输入 yes 并回车。 接着出现 Hi xxx! You've successfully authenticated, but GitHub does not provide shell access. 则操作成功。 3、博客配置 打开你的博客文件夹，找到 _config.yml 文件并打开，在最后修改并添加如下代码： yml1234deploy: type: git repo: https://github.com/YourgithubName/YourgithubName.github.io.git branch: master 将 YourgithubName 改为你的 github 账号名。保存文件。 回到博客文件夹的根目录，右键选择 Git Bash Here 选项，分别执行以下命令： Code123hexo cleanhexo ghexo s 接着打开浏览器，在浏览器中输入 http://localhost:4000 即可看到你的本地博客了。 4、博客上传 在博客文件夹的根目录，右键选择 Git Bash Here 选项，输入 npm install hexo-deployer-git --save 安装部署到 github 的插件。 然后执行以下命令： Code123hexo cleanhexo ghexo d 中途可能会出现弹窗需要输入 github 账号和密码。输入完即可。 接下来等待十分钟左右，等待 github 将博客文件配置完成。 在浏览器中输入 https://yourgithubname.github.io （yourgithubname 为你的 github 账号名）即可看到你的个人博客了。 5、创建文章 博客搭建完成后，在博客文件夹的根目录，右键选择 Git Bash Here 选项，输入 hexo n yourtitle （yourtitle 改为你自定义的文章标题）即可创建文章，文章保存的路径在 博客文件夹根目录/source/_posts 文件夹中，文件格式为 markdown 格式，想要写文章的朋友可以自学 markdown 语法，然后就可以打开这个文件进行写作了。 写作完成后，进入你的博客文件夹根目录，右键选择 Git Bash Here 选项 ，输入： Code123hexo cleanhexo ghexo d 即可上传到 github。 6、绑定域名 不需要更换域名的朋友可以跳过这一节。 GitHub Pages 支持使用自己的域名，喜欢个性化的朋友可以选择一个合适的域名绑定博客。 以下用阿里云举例。 首先购买一个域名，购买完成后，如果没有进行过实名认证的话，一定要进行实名认证，也就是域名状态那里。 进行实名认证后，进行域名解析。首先进入博客文件夹根目录，右键选择 Git Bash Here 选项，然后输入 ping @yourname.github.io ，得到 IP 并复制。 进入阿里云控制台，点击域名后面的 解析，添加如下记录： 记录类型 主机记录 记录值 TTL CNAME @ yourname.github.io 10分钟 A www yourIP 10分钟 将 yourname 改为你的 github 账户名，将 yourIP 改为你刚才复制的 IP。其他保持默认即可。 进入 github，打开刚刚创建的仓库，打开 Setting ，找到 Github pages ，在 Custom domain 里输入你购买的域名，例如: www.yourname.com ( www. 可以不写 ) ，点击 save ，勾选下面的 Enforce HTTPS 选项。 进入博客文件夹根目录，找到 source ，在里面创建一个文本文档，输入你购买的域名，例如： www.yourname.com ( www. 可以不写 )，保存后重命名为 CNAME ，并将文件后缀名删除。 然后进入博客文件夹根目录，右键选择 Git Bash Here 选项，输入 hexo d -g 即可。等待 10 分钟左右时间便可以用新域名访问博客。 7、hexo 常用指令 平常我们用到的指令如下： hexo clean：清除缓存文件和已生成的静态文件。 hexo g：生成静态文件。 hexo s：启动服务器。默认情况下，访问网址为： http://localhost:4000/ 。 hexo d：部署网站。 hexo v：显示 Hexo 版本。 可以进入Hexo文档 查看更多指令。 8、博客配置文件详解 “配置文件” 为博客根目录的 _config.yml 文件 部分注释来自互联网 yml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Site（标题等必填）#网站标题title:#网站副标题subtitle:#网站描述description:#作者昵称author:#网站语言，默认英语，设置简体中文language: zh-CN#时区，默认电脑时区timezone: Asia/Shanghai# URL#如果网站是放在子目录中，将url设置成'http://yoursite.com/child'，将root设置成'/child/'## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'#网址（输入你的GitHub Pages地址）url: http://用户名.github.io#网站根目录。如果网站是放在子目录中，将root设置成'子目录名'root: /#文章链接地址格式 。即文章存放的目录。（**注意**：为方便网络爬虫抓取博客信息，一般都会把网址设置成“三段”，而Hexo默认为“域名:年:月:日:标题”五段。强烈建议修改为**:year:month:day/:title/**以便于抓取。）permalink: :year:month:day/:title/permalink_defaults:# Directory#资源文件夹，放在里面的文件会上传到github中source_dir: source#公共文件夹，存放生成的静态文件public_dir: public#标签文件夹，默认是tags。实际存放在source/tags中。tag_dir: tagsrss_dir: rss#档案文件夹，默认是archives。archive_dir: archives#分类文件夹，默认是categories。实际存放在source/categories中。category_dir: categories#代码文件夹，默认是downloads/codecode_dir: downloads/code#国际化文件夹，默认跟language相同i18n_dir: :lang#不需要渲染的文件夹或文件夹,格式为[文件名]skip_render:# Writing# 新建博文（帖子）的默认名称# File name of new postsnew_post_name: :title.md#默认布局模板是post，而不是draft和pagedefault_layout: post#是否将标题转换成标题形式（首字母大写）titlecase: false # Transform title into titlecase#在新标签页面中打开网页external_link: true # Open external links in new tabfilename_case: 0#是否渲染草稿render_drafts: false#启动 Asset 文件夹post_asset_folder: false#把链接改为与根目录的相对位址relative_link: false#显示未来的文章future: true#代码块的设置highlight:enable: true # 使用代码高亮line_number: true # 显示行号auto_detect: true # 自动检测语言tab_replace:# Home page setting# path: Root path for your blogs index page. (default = '')# per_page: Posts displayed per page. (0 = disable pagination)# order_by: Posts order. (Order by date descending by default)index_generator:path: ''#每页文章数量per_page: 10#排序依据order_by: -date# Category &amp; Tag#默认分类default_category: uncategorized#分类别名category_map:#标签别名tag_map:# Date / Time format#Hexo 使用 Moment.js 来解析和显示时间。## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page# Extensions 拓展插件配置## Plugins: https://hexo.io/plugins/#主题配置## Themes: https://hexo.io/themes/#选择主题,默认为landscapetheme: landscape# ---------------下面选项需要对应插件的支持---------------# 部署配置## Docs: https://hexo.io/docs/deployment.htmldeploy:type: gitrepo: git@github.com:用户名/用户名.github.io.gitbranch: master# 配置RSSfeed:#feed 类型 (atom/rss2)type: atom#rss 路径path: atom.xml#在 rss 中最多生成的文章数(0显示所有)limit: 0# 自定义站点内容搜索# 需要先安装插件：# npm install hexo-generator-search --savesearch:path: search.xml# 如只想索引文章，可设置为postfield: all# ---------------------------------------------------","categories":[{"name":"Blog","slug":"Blog","permalink":"https://zhangxiaocn.github.io/categories/Blog/"}],"tags":[{"name":"Blog","slug":"Blog","permalink":"https://zhangxiaocn.github.io/tags/Blog/"},{"name":"Hexo","slug":"Hexo","permalink":"https://zhangxiaocn.github.io/tags/Hexo/"}]}]}