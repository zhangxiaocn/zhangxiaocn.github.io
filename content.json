{"meta":{"title":"ZhangXiao's Blog","subtitle":"清风湿润，茶烟轻扬。","description":null,"author":"Zhang Xiao","url":"https://zhangxiaocn.github.io","root":"/"},"pages":[{"title":"关于","date":"2019-10-29T13:40:03.234Z","updated":"2019-10-29T13:40:03.234Z","comments":false,"path":"about/index.html","permalink":"https://zhangxiaocn.github.io/about/index.html","excerpt":"","text":"一名在校大学生，目前正在学习 ROS 相关知识。 联系邮箱：zhangxiaoim@foxmail.com 欢迎关注我的个人公众号：是你鸭鸭"},{"title":"分类","date":"2019-10-26T06:03:38.496Z","updated":"2019-10-26T06:03:38.496Z","comments":false,"path":"categories/index.html","permalink":"https://zhangxiaocn.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2019-10-26T07:15:40.459Z","updated":"2019-10-26T07:15:40.459Z","comments":true,"path":"links/index.html","permalink":"https://zhangxiaocn.github.io/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2019-10-26T06:23:34.166Z","updated":"2019-10-26T06:23:34.166Z","comments":false,"path":"repository/index.html","permalink":"https://zhangxiaocn.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-10-26T06:03:38.499Z","updated":"2019-10-26T06:03:38.499Z","comments":false,"path":"tags/index.html","permalink":"https://zhangxiaocn.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"PID 基础公式及程序","slug":"study-note-pid","date":"2019-10-30T12:21:32.000Z","updated":"2019-10-30T12:52:53.323Z","comments":true,"path":"2019/10/30/study-note-pid/","link":"","permalink":"https://zhangxiaocn.github.io/2019/10/30/study-note-pid/","excerpt":"","text":"仅用于备份本人所写笔记，如有错误或不完善之处还请包含。转载请注明出处！ 位置式离散 PID： Pwm=Kp×e(k)+Ki×∑e(k)+Kd×[e(k)−e(k−1)]Pwm = Kp \\times e(k) + Ki \\times \\sum e(k) + Kd \\times [e(k) - e(k-1)]Pwm=Kp×e(k)+Ki×∑e(k)+Kd×[e(k)−e(k−1)] e(k)e(k)e(k) : 本次偏差 e(k−1)e(k-1)e(k−1) : 上次偏差 ∑e(k)\\sum e(k)∑e(k) : e(k)e(k)e(k) 以及之前的偏差的累计和；其中 kkk 为 1,2,3…k1, 2, 3\\ldots k1,2,3…k； PwmPwmPwm : 代表输出 C 语言的实现： 12345678910111213141516// 位置式离散 PID// P = Kp * err;// I = Ki * integral_err;// D = Kd * (err - last_err);// Pwm = P + I + D;float PositionPid(int encoder, int target) &#123; static float err = 0, last_err = 0, integral_err = 0, pwm = 0; float kp = 1, ki = 1, kd = 1; err = encoder - target; // 计算偏差 integral_err += err; // 求出偏差积分 pwm = kp * err + ki * integral_err + kd * (err - last_err); last_err = err; // 保存上一次偏差 return pwm; // 输出&#125; 在舵机角度控制闭环系统里，只使用 PD 控制，因此可将 PID 控制简化为此公式： Pwm=Kp×e(k)+Kd×[e(k)−e(k−1)]Pwm = Kp \\times e(k) + Kd \\times [e(k) - e(k-1)]Pwm=Kp×e(k)+Kd×[e(k)−e(k−1)] 代码更改如下： 1234567891011121314// 位置式离散 PD// P = Kp * err;// D = Kd * (err - last_err);// Pwm = P + D;float PositionPid(int encoder, int target) &#123; static float err = 0, last_err = 0, integral_err = 0, pwm = 0; float kp = 1, ki = 1, kd = 1; err = encoder - target; // 计算偏差 pwm = kp * err + kd * (err - last_err); last_err = err; // 保存上一次偏差 return pwm; // 输出&#125; PID 参数整定： P：用于提高相应速度 I：用于减小静差 D：用于抑制震荡 增量式离散 PID： Pwm+=Kp×[e(k)−e(k−1)]+Ki×e(k)+Kd×[e(k)−2e(k−1)+e(k−2)]Pwm += Kp × [e(k) - e(k-1)] + Ki × e(k) + Kd × [e(k) - 2e(k-1) + e(k-2)]Pwm+=Kp×[e(k)−e(k−1)]+Ki×e(k)+Kd×[e(k)−2e(k−1)+e(k−2)] e(k)e(k)e(k) : 本次偏差 e(k−1)e(k-1)e(k−1) : 上次的偏差 e(k−2)e(k-2)e(k−2) : 上上次的偏差 PwmPwmPwm : 代表增量输出 C 语言实现： 1234567891011121314151617// 增量式离散 PID// P = Kp * (err - last_err);// I = Ki * err;// D = Kd * (err - 2 * last_err + before_err);// Pwm += P + I + D;float IncrementalPid(int encoder, int target) &#123; static float err = 0, last_err = 0, before_err = 0, pwm = 0; float kp = 1, ki = 1, kd = 1; err = encoder - target; // 计算偏差 pwm += kp * (err - last_err) + ki * err + kd * (err - 2 * last_err + before_err); // 增量式 PI 控制器 before_err = last_err; // 保存上上次偏差 last_err = err; // 保存上一次偏差 return pwm; // 增量输出&#125; 在速度控制闭环系统里，只使用 PI 控制，因此可将 PID 控制简化为此公式： Pwm+=Kp×[e(k)−e(k−1)]+Ki×e(k)Pwm += Kp × [e(k) - e(k-1)] + Ki × e(k)Pwm+=Kp×[e(k)−e(k−1)]+Ki×e(k) 代码更改如下： 1234567891011121314// 增量式离散 PI// P = Kp * (err - last_err);// I = Ki * err;// Pwm += P + I;float IncrementalPid(int encoder, int target) &#123; static float err = 0, last_err = 0, pwm = 0; float kp = 1, ki = 1, kd = 1; err = encoder - target; // 计算偏差 pwm += kp * (err - last_err) + ki * err; // 增量式 PI 控制器 last_err = err; // 保存上一次偏差 return pwm; // 增量输出&#125;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://zhangxiaocn.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"PID","slug":"PID","permalink":"https://zhangxiaocn.github.io/tags/PID/"}]},{"title":"K60 中断的使用","slug":"k60-interrupt","date":"2019-10-30T12:16:02.000Z","updated":"2019-10-30T12:18:34.948Z","comments":true,"path":"2019/10/30/k60-interrupt/","link":"","permalink":"https://zhangxiaocn.github.io/2019/10/30/k60-interrupt/","excerpt":"","text":"仅用于备份本人所写笔记，如有错误或不完善之处还请包含。转载请注明出处！ 程序使用逐飞科技 K60 库 V2.0.3 首先，中断需要初始化以及定义中断的时间： 1pit_init_ms(pit1, 1); // 设置中断时间为 1ms 中断时间过长，会造成程序运行后出现的效果非常迟钝。 中断时间过短，可能会使中断里的程序运行时间不够，从而造成溢出。 所以在时间方面需要细心拿捏。 设置中断的优先级： 1set_irq_priority(PIT1_IRQn, 1); // 设置优先级 设置完成后，就可以打开中断，开始运行： 1enable_irq(PIT1_IRQn); // 打开中断 1 运行中断时，需要注意中断里的程序最好不要过多，尽可能不要有延时函数。 1234567// 中断 1void PIT1_IRQHandler(void) &#123; // 用户程序 PIT_FlAG_CLR(pit1); // 中断标志清除&#125; 这样就基本实现了中断的初始化及运行。 当然我们也可以同时用两个甚至多个中断，让它们同时运行。但是，中断过多可能会出现一些问题。比如： 出现同时两个中断满足进入中断的条件时，这时就会根据中断优先级进行判断先进入哪个中断服务程序里，高优先级的执行完毕才会进入低优先级中断。 如果正在执行中断服务程序（中断1）时，另一个中断（中断2）触发，如果 2 优先级高于 1，那么会立即执行中断2的服务程序，等中断2 执行完毕，才会继续执行中断1。如果中断 2 优先级低于中断1，则等待中断1 执行完毕才会执行中断2。 也就是说，如果两个或者多个中断同时满足运行条件，可能会造成低优先级中断里的程序没有机会运行，从而影响使用。所以，没有太大必要的情况下，不建议同时使用多个中断。 那么，如果只用一个中断，而我又需要让程序在不同的时间下运行该怎么办呢？ 如下给出一个可行的方案： 1234567891011121314151617181920212223// 中断 0，计时 1msvoid PIT0_IRQHandler(void) &#123; timeCount++; // 每运行一次中断，值 +1 if (timeCount % 1 == 0 ) &#123; timeFlag_1ms = 1; &#125; // 1ms 标志 if (timeCount % 2 == 0 ) &#123; timeFlag_2ms = 1; &#125; // 2ms 标志 if (timeCount % 5 == 0 ) &#123; timeFlag_5ms = 1; &#125; // 5ms 标志 if (timeCount % 10 == 0 ) &#123; timeFlag_10ms = 1; &#125; // 10ms 标志 if (timeCount % 20 == 0 ) &#123; timeFlag_20ms = 1; &#125; // 20ms 标志 if (timeCount % 50 == 0 ) &#123; timeFlag_50ms = 1; &#125; // 50ms 标志 if (timeCount % 200 == 0 ) &#123; timeFlag_200ms = 1; timeCount = 0; &#125; // 200ms 标志，并清除计时标志 if (timeFlag_1ms == 1) &#123; timeFlag_1ms = 0; ... &#125; // 每 1ms 运行一次程序 if (timeFlag_2ms == 1) &#123; timeFlag_2ms = 0; ... &#125; // 每 2ms 运行一次程序 if (timeFlag_5ms == 1) &#123; timeFlag_5ms = 0; ... &#125; // 每 5ms 运行一次程序 if (timeFlag_10ms == 1) &#123; timeFlag_10ms = 0; ... &#125; // 每 10ms 运行一次程序 if (timeFlag_20ms == 1) &#123; timeFlag_20ms = 0; ... &#125; // 每 20ms 运行一次程序 if (timeFlag_50ms == 1) &#123; timeFlag_50ms = 0; ... &#125; // 每 50ms 运行一次程序 if (timeFlag_200ms == 1) &#123; timeFlag_200ms = 0; ... &#125; // 每 200ms 运行一次程序 PIT_FlAG_CLR(pit0); // 中断标志清除&#125; 如上，让中断里的程序每 200ms 实现一次循环。只要将每个程序的运行时间设置到位，便可以让各个程序在不同的时间下运行。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://zhangxiaocn.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"K60","slug":"K60","permalink":"https://zhangxiaocn.github.io/tags/K60/"}]},{"title":"OpenMV 扫描 QR 码 + 串口通信","slug":"openmv-study-note-1","date":"2019-10-29T13:46:29.000Z","updated":"2019-10-29T13:50:24.117Z","comments":true,"path":"2019/10/29/openmv-study-note-1/","link":"","permalink":"https://zhangxiaocn.github.io/2019/10/29/openmv-study-note-1/","excerpt":"","text":"部分内容来自 凡哥带你玩转OpenMV 以及 OpenMV中文入门教程。 使用 TTL-USB 模块 备份一下我用的 TTL-USB 模块各接口，红线是 5V ，粉色线是 3V3 ，蓝色线是 TX ，绿色线是 RX ，黑色线是 GND 两个单片机进行串口通信，最少需要三根线相连： 发送端 TX 接收端 RX 地线 GND 例如 A 和 B 两个单片机，A 的 RX 需要接 B 的 TX ，B 的 RX 需要接 A 的 TX ，二者的地线 GND 相连作为参考电平。 VCC 可接可不接，USB 的串口是 5V 的，如果要接 OpenMV 板子上的话， 需要接在 OpenMV 的 VIN 上， 如果接在 3v3, 也就是 3.3v 的接口处， 会使所有的元器件暴露在 5v 的电压下， 导致电子元器件全部烧毁。 OpenMV 串口资源 OpenMV 引脚图 UART 3 ： Pin Name Uart Index Role P4 串口 3 TX 发送端 P5 串口 3 RX 接收端 串口助手 推荐下载星瞳串口助手：https://singtown.com/singtownserialport/ 或者友善串口调试助手，百度搜索下载即可。 软件设置： 波特率：115200 数据为：8 校验位：None 停止位：1 流控：None 接收设置：ASCII 发送设置：Hex 串口通信程序 UART 对象 更多详细操作请转到 UART 官方文档： http://docs.micropython.org/en/latest/pyboard/library/pyb.UART.html?highlight=uart 初始化UART对象： 123456/** 初始化一个串口对象* uart_idx , 串口 ID， 我们这里只能写 1 或者 3* baud_rate , 波特率 */UART(uart_idx, baud_rate) 12# 初始化 UART 对象uart = UART(3, 115200) 更多操作： 123456# 读写操作uart.read(10) # 读入 10 个字符， 返回一个比特对象 uart.read() # 读取所有的有效字符uart.readline() # 读入一行uart.readinto(buf) # 读入并且保存在缓存中uart.write('abc') # 向串口写入3个字符abc 123# 单个字符的读取与写入uart.readchar() # 读入一个字符uart.writechar(42) # 写入 ASCALL 码为 42 的字符 12# 判断串口是否有数据uart.any() 向串口发送数据 12345678910import timefrom pyb import UART# 初始化 UART 对象uart = UART(3, 115200)uart.init(115200, bits=8, parity=None, stop=1) # init with given parameterswhile(True): uart.write(\"Hello World!!!\\r\") print(\"Hello World\") time.sleep(1000) # 休眠 1s 向串口接收数据 1234567891011121314import timefrom pyb import UART# 初始化 UART 对象uart = UART(3, 115200)uart.init(115200, bits=8, parity=None, stop=1) # init with given parameterswhile(True): # 判断是否有数据 if uart.any(): tmp_data = uart.readline() print(tmp_data) time.sleep(1000) # 休眠 1s 数据双向发送与接收 123456789101112131415161718192021222324import timefrom pyb import UART# 初始化 UART 对象uart = UART(3, 115200)uart.init(115200, bits=8, parity=None, stop=1) # init with given parameters# 发送数据def sending_data(): global uart uart.write(\"HelloWorld!!!\\n\")# 接收数据def recive_data(): global uart if uart.any(): tmp_data = uart.readline() uart.write(\"Recived : %s\\n\" % tmp_data) print(tmp_data)while(True): sending_data() recive_data() time.sleep(1000) # 休眠 1s 扫描 QR 码 可以用 草料二维码 生成想要的 QR 码内容 程序如下： 1234567891011121314151617import sensor, imagesensor.reset()sensor.set_pixformat(sensor.RGB565)sensor.set_framesize(sensor.QQVGA) # can be QVGA on M7...sensor.skip_frames(30) # 修改 sensor 配置之后，跳过30帧sensor.set_auto_gain(False) # must turn this off to prevent image washout...while(True): img = sensor.snapshot() # 拍摄一张照片，snapshot() 函数返回一个 image 对象 img.lens_corr(1.8) # strength of 1.8 is good for the 2.8mm lens. # 用来防止 115 度的摄像头拍摄出来的图像畸变(鱼眼) for code in img.find_qrcodes(): # find_qrcodes 用于寻找二维码 print(code) # 返回对象格式如下： # &#123;x:**, y:**, w:**, h:**, payload:\"**\", version:*, ecc_level:*, mask:*, data_type:*, eci:*&#125; # payload 就是在二维码下隐藏的信息 扫描 QR 码后通过串口发送数据 简单说就是把串口发送数据程序和扫描 QR 码程序放在一块就好了 12345678910111213141516171819202122232425import timefrom pyb import UARTimport sensor, imagesensor.reset()sensor.set_pixformat(sensor.RGB565)sensor.set_framesize(sensor.QQVGA) # can be QVGA on M7...sensor.skip_frames(30) # 修改 sensor 配置之后，跳过30帧sensor.set_auto_gain(False) # must turn this off to prevent image washout...# 初始化 UART 对象uart = UART(3, 115200)uart.init(115200, bits = 8, parity = None, stop = 1)while(True): img = sensor.snapshot() # 拍摄一张照片，snapshot() 函数返回一个 image 对象 img.lens_corr(1.8) # 用来防止 115 度的摄像头拍摄出来的图像畸变(鱼眼) for code in img.find_qrcodes(): # find_qrcodes 用于寻找二维码 uart.write(code.payload()) # 串口读取二维码数据 # if code = \"123\" # 返回对象格式如下： # &#123;x, y, w, h, payload:\"**\", version:*, ecc_level:*, mask:*, data_type:*, eci:*&#125; # payload 就是我们在二维码下隐藏的信息 print(code) # 输出二维码内容 time.sleep(500) # 休息 0.5s","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://zhangxiaocn.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"OpenMV","slug":"OpenMV","permalink":"https://zhangxiaocn.github.io/tags/OpenMV/"}]},{"title":"简述 K60 直流电机闭环控制","slug":"k60-motor-control","date":"2019-10-29T13:41:02.000Z","updated":"2019-10-29T13:44:33.298Z","comments":true,"path":"2019/10/29/k60-motor-control/","link":"","permalink":"https://zhangxiaocn.github.io/2019/10/29/k60-motor-control/","excerpt":"","text":"仅用于备份本人所写笔记，如有错误或不完善之处还请包含。转载请注明出处！ 程序使用逐飞科技 K60 库 V2.0.3 电机速度闭环控制，简单来说就是将电机的输出量（速度）通过编码器反馈到控制端（单片机），然后对该输出量和设定的输入量进行比对，接着经过 PID 运算，将运算结果输入给电机的过程。 电机速度闭环一个显而易见的好处就是，可以让小车在不同的路段动态调整小车的速度，如果参数调整的好，可以让小车极大的提升对赛道的适应性能，减少小车跑完一圈所需的时间。 闭环控制思路比较简单，首先需要获取编码器的值，每 4ms 取一次值（可以设定其他时间），然后将取到的值进行相应的计算，得出电机当前速度。 代码示例： 123456789101112131415161718192021222324252627282930313233343536const float unit_pulse = 1783.0; // 小车轮胎旋转一周（360°）的脉冲const float motor_radius = 0.063; // 电机轮胎半径（米）// 编码器初始化void EncoderInit(void) &#123; ftm_quad_init(ftm2); // 初始化 ftm2 为正交解码 port_init_NoAlt(B18, PULLUP); // 上拉 port_init_NoAlt(B19, PULLUP); // 上拉&#125;// 读取编码器值float EncoderRead(void) &#123; float data = 0; data = ftm_quad_get(ftm2); // 获取编码器的脉冲值 ftm_quad_clean(ftm2); // 清除正交解码的脉冲值 return data;&#125;// 计算电机当前速度// 输入值为运行该程序的间隔时间float GetMotorSpeed(uint16 run_time_ms) &#123; float motor_speed = 0; encoder.finalValue += 0.25f * (encoder.value - encoder.finalValue); // 一阶低通滤波 encoder.motorRounds = (encoder.finalValue * run_time_ms) / unit_pulse; // 电机每 1s 转的圈数 encoder.motorDistance = encoder.motorRounds * (2 * PI * motor_radius); // 电机运行长度 m motor_speed = encoder.motorDistance / 1; // 电机速度 m/s return motor_speed;&#125; 计算出速度后，把该变量赋值给 PID 计算，算出需要输出给电机的占空比。PID 计算公式可以根据实际情况稍作修改优化。 代码示例： 1234567891011121314151617181920// 电机 pid 程序void MotorPid(void) &#123; static float err, last_err, expect_pwm; // 请根据实际情况修改 KP、KI 参数大小 motor_pid.kp = 0.1; motor_pid.ki = 0.2; err = motor.expectSpeed - encoder.motorSpeed; expect_pwm += motor_pid.kp * (err - last_err) + motor_pid.ki * err; last_err = err; // 电机占空比限幅 // 请根据实际情况修改最大和最小 PWM 参数值 if (expect_pwm &gt; 260) expect_pwm = 260; if (expect_pwm &lt;= 0) expect_pwm = 0; // 将值转换为正整数类型 motor.expectDutyRatio = (uint16)(expect_pwm);&#125; PID 返回期望占空比赋值给电机控制函数： 12345// 电机控制程序void MotorControl(void) &#123; MotorPid(); MotorPWM(0, motor.expectDutyRatio);&#125; 这样就实现了简单的电机速度闭环控制。当然这只算是比较基础的闭环，若要实现复杂功能，还需进行大量优化。 如下为本文闭环全部代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124/******************************************************************************************* * COPYRIGHT NOTICE * Copyright (c) 2019, ZhangXiao * All rights reserved. * * 本文件仅供参考交流，未经允许不得用于商业用途！ * * File : motor.c * Author : ZhangXiao * Blog : zhangxiaocn.github.io * Version : v1.0.1 * Date : 2019-08-06 * Software : IAR 7.70.1 * Description : 电机相关程序以及 PID、编码器程序等 * note : None********************************************************************************************/#include \"motor.h\"#include \"headfile.h\"const float unit_pulse = 1783.0; // 小车轮胎旋转一周（360°）的脉冲const float motor_radius = 0.063; // 电机轮胎半径（米）// 电机 pid 程序结构体参数struct MOTOR_PID motor_pid = &#123;0.1, 0.2, 0, 0, 0, 0, 0, 0&#125;;// 编码器结构体struct ENCODER encoder = &#123;0, 0, 0, 0, 0&#125;;// 电机结构体struct MOTOR motor = &#123;0, 0, 0&#125;;// 电机初始化// FTM1_CH0_PIN 端口为 A12// FTM1_CH1_PIN 端口为 A13// 电机初始化频率默认为 10k，请根据实际情况更改频率大小void MotorInit(void) &#123; ftm_pwm_init(ftm1, ftm_ch0, 10 * 1000, 0); ftm_pwm_init(ftm1, ftm_ch1, 10 * 1000, 0);&#125;// 电机 PWM 控制void MotorPWM(uint16 pwm_1, uint16 pwm_2) &#123; ftm_pwm_duty(ftm1, ftm_ch0, pwm_1); // A12 端口 ftm_pwm_duty(ftm1, ftm_ch1, pwm_2); // A13 端口&#125;// 编码器初始化void EncoderInit(void) &#123; ftm_quad_init(ftm2); // 初始化 ftm2 为正交解码 port_init_NoAlt(B18, PULLUP); // 上拉 port_init_NoAlt(B19, PULLUP); // 上拉&#125;// 读取编码器值float EncoderRead(void) &#123; float data = 0; data = ftm_quad_get(ftm2); // 获取编码器的脉冲值 ftm_quad_clean(ftm2); // 清除正交解码的脉冲值 return data;&#125;// 计算电机当前速度// 输入值为运行该程序的间隔时间float GetMotorSpeed(uint16 run_time_ms) &#123; float motor_speed = 0; encoder.finalValue += 0.25f * (encoder.value - encoder.finalValue); // 一阶低通滤波 encoder.motorRounds = (encoder.finalValue * run_time_ms) / unit_pulse; // 电机每 1s 转的圈数 encoder.motorDistance = encoder.motorRounds * (2 * PI * motor_radius); // 电机运行长度 m motor_speed = encoder.motorDistance / 1; // 电机速度 m/s return motor_speed;&#125;// 计算电机运行距离// 输入值为运行该程序的间隔时间float GetMotorDistance(uint16 run_time_ms) &#123; return encoder.motorDistance / run_time_ms;&#125;// 编码器相关参数计算// 输入值为运行该程序的间隔时间// 程序建议每 4ms 运行一次，即 Encoder_Calculate(4);void EncoderCalculate(uint16 run_time_ms) &#123; uint16 run_time = 1000 / run_time_ms; // 每秒钟运行此程序次数 encoder.value = EncoderRead(); // 读取编码器的值 encoder.motorSpeed = GetMotorSpeed(run_time); // 计算电机当前速度 motor.distance += GetMotorDistance(run_time); // 获取电机距离&#125;// 电机 pid 程序void MotorPid(void) &#123; static float err, last_err, expect_pwm; // 请根据实际情况修改 KP、KI 参数大小 motor_pid.kp = 0.1; motor_pid.ki = 0.2; err = motor.expectSpeed - encoder.motorSpeed; expect_pwm += motor_pid.kp * (err - last_err) + motor_pid.ki * err; last_err = err; // 电机占空比限幅 // 请根据实际情况修改最大和最小 PWM 参数值 if (expect_pwm &gt; 260) expect_pwm = 260; if (expect_pwm &lt;= 0) expect_pwm = 0; // 将值转换为正整数类型 motor.expectDutyRatio = (uint16)(expect_pwm);&#125;// 电机控制程序void MotorControl(void) &#123; MotorPid(); MotorPWM(0, motor.expectDutyRatio);&#125;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://zhangxiaocn.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"K60","slug":"K60","permalink":"https://zhangxiaocn.github.io/tags/K60/"}]},{"title":"IAR 软件自用技巧","slug":"iar-setting","date":"2019-10-29T13:35:35.000Z","updated":"2019-10-29T13:44:47.200Z","comments":true,"path":"2019/10/29/iar-setting/","link":"","permalink":"https://zhangxiaocn.github.io/2019/10/29/iar-setting/","excerpt":"","text":"更改背景 效果如下： 点击 Tools -&gt; options 选择 Editor -&gt; Colors and Fonts 点击 Font，选择文字为 Consolas ，Size 选择 三号（按照自己的喜好设置大小） Syntax Coloring 一栏中设置如下： type Color（颜色） Type Style（类型风格） Background Color（背景颜色） Default White Normal Black C Keyword Lime Bold Black Strings Yellow Normal Black Char Aqua Normal Black Preprocessor Silver Normal Black Number Yellow Normal Black C++ Comment Aqua Italic Black comment Aqua Italic Black User Keyword Aqua Italic Black Compiler keyword Aqua Italic Black Asm keyword Fuchsia Bold Black Asm comment Lime Italic Black 解决函数无法跳转问题 点击 Tools -&gt; options 选择 Project 关闭 Generate browse information ，点击确定 再次进入设置并重复以上步骤，把刚才关闭的 Generate browse information 选项打开，点击确定 在软件左侧 Workspace 中，右键第一个文件，点击 Rebuild All ，等待右下角绿色进度条走完 打开软件左侧 Workspace 点击 View -&gt; Workspace即可 软件缺少任何视图都可以在 View 栏中找到并打开 用山外调试助手烧录 K60 程序错误问题 在软件左侧 Workspace 中找到 Files 里的第一个文件并右击鼠标，选择 Options 选择 General Options 中，把 Device 改为 NXP MK60FX512xxx15 选择 Debugger ，在 Setup 中把 Driver 改为 CMSIS DAP ，在 Download 中把框中的文字改为 $TOOLKIT_DIR$\\config\\flashloader\\NXP\\FlashK60Fxxx128K.board 选择 CMSIS DAP ，在 interface 栏中把 JTAG 改为 SWD 未完待续…","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://zhangxiaocn.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"IAR","slug":"IAR","permalink":"https://zhangxiaocn.github.io/tags/IAR/"},{"name":"开发软件","slug":"开发软件","permalink":"https://zhangxiaocn.github.io/tags/%E5%BC%80%E5%8F%91%E8%BD%AF%E4%BB%B6/"}]},{"title":"换电脑后快速恢复 hexo 博客","slug":"continue-blog","date":"2019-10-29T13:23:54.000Z","updated":"2019-10-29T13:32:03.700Z","comments":true,"path":"2019/10/29/continue-blog/","link":"","permalink":"https://zhangxiaocn.github.io/2019/10/29/continue-blog/","excerpt":"","text":"前言 使用 Github + hexo 搭建一个个人博客是需要花不少时间的，搭建好后如果有一天电脑突然坏了，或者重装了系统，那么我们怎么使用 hexo 再发布文章到个人博客呢？其实方法还是有的！ 操作方法 安装软件 安装 Git 客户端 安装 node JS：建议下载 LTS 长期支持版 在 github 官网添加新电脑的密钥 在本地创建 SSH Keys： 1ssh-keygen -t rsa -C &quot;@邮箱&quot; 一路回车。 进入 C:\\Users\\用户名.ssh，打开 id_rsa.pub 文件，复制里面所有的内容，然后进入 github 页面，点击右上角的 头像 &gt; Settings ，在左侧找到 SSH and GPG keys。 点击 New SSH key ，Title 里的内容可以自定义，Key 里填入复制的内容。点击 add key。 返回窗口，输入： 1ssh -T git@github.com 若弹出 Are you sure you want to continue connecting (yes/no)? 时输入 yes 确认。 接着出现 Hi xxx! You've successfully authenticated, but GitHub does not provide shell access. 则操作成功。 复制源文件到新电脑 将你原来电脑上个人博客目录下必要文件拷到你的新电脑上（比如 E:/Blog 目录下），注意无需拷全部，只拷如下几个目录： _config.yml package.json scaffolds/ source/ themes/ 安装 Hexo 在命令行输入： 1npm install hexo-cli -g 进入 E:/Blog 目录（新电脑的博客目录），输入下面指令安装相关模块： 12345npm installnpm install hexo-deployer-git --save // 文章部署到 git 的模块（下面为选择安装）npm install hexo-generator-feed --save // 建立 RSS 订阅npm install hexo-generator-sitemap --save // 建立站点地图 测试是否成功 命令行输入： 123hexo clean // 清除缓存 网页正常情况下可以忽略此条命令hexo g // 生成静态网页hexo s // 启动服务器 访问网址： http://localhost:4000/ 若能正常显示则成功。","categories":[{"name":"Blog","slug":"Blog","permalink":"https://zhangxiaocn.github.io/categories/Blog/"}],"tags":[{"name":"Blog","slug":"Blog","permalink":"https://zhangxiaocn.github.io/tags/Blog/"},{"name":"Hexo","slug":"Hexo","permalink":"https://zhangxiaocn.github.io/tags/Hexo/"}]},{"title":"Hexo NexT 主题的启用及设置","slug":"hexo-theme-next","date":"2019-10-29T13:05:08.000Z","updated":"2019-10-29T13:25:47.211Z","comments":true,"path":"2019/10/29/hexo-theme-next/","link":"","permalink":"https://zhangxiaocn.github.io/2019/10/29/hexo-theme-next/","excerpt":"","text":"主题的启用 下载并启用 进入命令行，下载 NexT 主题，输入： 1git clone https://github.com/theme-next/hexo-theme-next themes/next 修改站点配置文件 _config.yml，找到如下代码： 12## Themes: https://hexo.io/themes/theme: landscape 将 landscape 修改为 next 即可。 修改语言 打开站点配置文件，搜索 language，找到如下代码： 123author:language:timezone: 在 language 后面输入 zh-CN。 注意：冒号后面必须有一个空格。 主题的设置 新建标签及分类界面 打开 主题配置文件，搜索 menu，找到如下代码： 123456789menu: home: / || home #about: /about/ || user #tags: /tags/ || tags #categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat 把 tags 和 categories 前面的 # 删除，进入命令行，输入： 12hexo n page tagshexo n page categories 进入博客主目录 Hexo/source，找到 tags 和 categories 文件夹，分别进入并修改文件夹内的文件。例如，先进入 tags 文件夹，打开 index.md 文件，在 date 下一行输入： 1type: \"tags\" 修改 categories 文件夹下的文件时，只需把上面的 tags 代码改成 categories 即可。 切换主题 next 主题自带四种样式。 在主题配置文件 /next/_config.yml 中查找：scheme，找到如下代码： 12345# Schemesscheme: Muse#scheme: Mist#scheme: Pisces#scheme: Gemini 选择你喜欢的一种样式，去掉前面的 #，其他主题前加上 # 即可。 隐藏网页底部 powered By Hexo / 强力驱动 打开 themes/next/layout/_partials/footer.swig 找到： 123456789101112131415161718&#123;% if theme.footer.powered.enable %&#125; &lt;div class=&quot;powered-by&quot;&gt;&#123;# #&#125;&#123;&#123; __(&apos;footer.powered&apos;, &apos;&lt;a class=&quot;theme-link&quot; target=&quot;_blank&quot;&apos; + nofollow + &apos; href=&quot;https://hexo.io&quot;&gt;Hexo&lt;/a&gt;&apos;) &#125;&#125;&#123;% if theme.footer.powered.version %&#125; v&#123;&#123; hexo_env(&apos;version&apos;) &#125;&#125;&#123;% endif %&#125;&#123;##&#125;&lt;/div&gt;&#123;% endif %&#125;&#123;% if theme.footer.powered.enable and theme.footer.theme.enable %&#125; &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;&#123;% endif %&#125;&#123;% if theme.footer.theme.enable %&#125; &lt;div class=&quot;theme-info&quot;&gt;&#123;# #&#125;&#123;&#123; __(&apos;footer.theme&apos;) &#125;&#125; – &#123;# #&#125;&lt;a class=&quot;theme-link&quot; target=&quot;_blank&quot;&#123;&#123; nofollow &#125;&#125; href=&quot;https://theme-next.org&quot;&gt;&#123;# #&#125;NexT.&#123;&#123; theme.scheme &#125;&#125;&#123;# #&#125;&lt;/a&gt;&#123;% if theme.footer.theme.version %&#125; v&#123;&#123; version &#125;&#125;&#123;% endif %&#125;&#123;##&#125;&lt;/div&gt;&#123;% endif %&#125; 把这段代码首尾分别加上：&lt;!-- 和 --&gt;，或者直接删除。 文章添加阴影 打开 /themes/next/source/css/_custom/custom.styl，添加： 1234567.post &#123; margin-top: 60px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5); &#125; 浏览页面显示当前浏览进度 打开 themes/next/_config.yml，搜索关键字 scrollpercent，把 false 改为 true。 Local Search本地搜索 在站点的根目录下执行以下命令： 1npm install hexo-generator-searchdb --save 编辑站点配置文件，新增以下内容到任意位置： 12345search: path: search.xml field: post format: html limit: 10000 编辑主题配置文件，启用本地搜索功能： 123# Local searchlocal_search: enable: true 设置个人头像 打开 主题配置文件，找到 Sidebar Avatar 字段： 123456789101112# Sidebar Avataravatar: # in theme directory(source/images): /images/avatar.gif # in site directory(source/uploads): /uploads/avatar.gif # You can also use other linking images. url: #/images/avatar.jpg # If true, the avatar would be dispalyed in circle. rounded: false # The value of opacity should be choose from 0 to 1 to set the opacity of the avatar. opacity: 1 # If true, the avatar would be rotated with the cursor. rotated: false 将 url 后面的 # 删掉，然后把你的头像命名为 avatar.jpg 放入 themes/next/source/images 中 rounded ：设置头像为圆形 opacity ：设置头像的不透明度 rotated ：设置头像可旋转 设置站点建立时间 在 主题配置文件 中，搜索：since，修改 since 后面的值即可，例如： 1since: 2013 设置网站图标 在 EasyIcon 中找一张（32*32）的 ico 图标，或者去别的网站下载或者制作，并将图标名称改为favicon.ico，然后把图标放在 /themes/next/source/images 里，并且修改主题配置文件： 12# Put your favicon.ico into `hexo-site/source/` directory.favicon: /favicon.ico 修改文章底部的 # 号的标签 修改模板 /themes/next/layout/_macro/post.swig 搜索 rel=&quot;tag&quot;&gt;#，将 # 换成 &lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt; 网站底部字数统计 切换到根目录下，运行如下代码： 1npm install hexo-wordcount --save 然后在 /themes/next/layout/_partials/footer.swig 文件尾部加上： 1234&lt;div class=\"theme-info\"&gt; &lt;div class=\"powered-by\"&gt;&lt;/div&gt; &lt;span class=\"post-count\"&gt;博客全站共&#123;&#123; totalcount(site) &#125;&#125;字&lt;/span&gt;&lt;/div&gt; 添加点击爱心效果 在 /themes/next/source/js/src 下新建文件 clicklove.js，接着把如下代码复制粘贴到 clicklove.js 文件中，代码如下： 1!function(e,t,a)&#123;function n()&#123;c(\".heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;\"),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText=\"left:\"+d[e].x+\"px;top:\"+d[e].y+\"px;opacity:\"+d[e].alpha+\";transform:scale(\"+d[e].scale+\",\"+d[e].scale+\") rotate(45deg);background:\"+d[e].color+\";z-index:99999\");requestAnimationFrame(r)&#125;function o()&#123;var t=\"function\"==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement(\"div\");a.className=\"heart\",d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement(\"style\");a.type=\"text/css\";try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName(\"head\")[0].appendChild(a)&#125;function s()&#123;return\"rgb(\"+~~(255*Math.random())+\",\"+~~(255*Math.random())+\",\"+~~(255*Math.random())+\")\"&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document); 在 \\themes\\next\\layout\\_layout.swig 文件末尾添加： 12&lt;!-- 页面点击小红心 --&gt;&lt;script type=\"text/javascript\" src=\"/js/src/clicklove.js\"&gt;&lt;/script&gt; 点击爆炸效果 方法和那个点击出现爱心效果是差不多的，首先在 themes/next/source/js/src 里面建一个叫 fireworks.js 的文件，代码如下： 1\"use strict\";function updateCoords(e)&#123;pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top&#125;function setParticuleDirection(e)&#123;var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return&#123;x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)&#125;&#125;function createParticule(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function()&#123;ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()&#125;,a&#125;function createCircle(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color=\"#F00\",a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function()&#123;ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1&#125;,a&#125;function renderParticule(e)&#123;for(var t=0;t&lt;e.animatables.length;t++)&#123;e.animatables[t].target.draw()&#125;&#125;function animateParticules(e,t)&#123;for(var a=createCircle(e,t),n=[],i=0;i&lt;numberOfParticules;i++)&#123;n.push(createParticule(e,t))&#125;anime.timeline().add(&#123;targets:n,x:function(e)&#123;return e.endPos.x&#125;,y:function(e)&#123;return e.endPos.y&#125;,radius:0.1,duration:anime.random(1200,1800),easing:\"easeOutExpo\",update:renderParticule&#125;).add(&#123;targets:a,radius:anime.random(80,160),lineWidth:0,alpha:&#123;value:0,easing:\"linear\",duration:anime.random(600,800)&#125;,duration:anime.random(1200,1800),easing:\"easeOutExpo\",update:renderParticule,offset:0&#125;)&#125;function debounce(e,t)&#123;var a;return function()&#123;var n=this,i=arguments;clearTimeout(a),a=setTimeout(function()&#123;e.apply(n,i)&#125;,t)&#125;&#125;var canvasEl=document.querySelector(\".fireworks\");if(canvasEl)&#123;var ctx=canvasEl.getContext(\"2d\"),numberOfParticules=30,pointerX=0,pointerY=0,tap=\"mousedown\",colors=[\"#FF1461\",\"#18FF92\",\"#5A87FF\",\"#FBF38C\"],setCanvasSize=debounce(function()&#123;canvasEl.width=2*window.innerWidth,canvasEl.height=2*window.innerHeight,canvasEl.style.width=window.innerWidth+\"px\",canvasEl.style.height=window.innerHeight+\"px\",canvasEl.getContext(\"2d\").scale(2,2)&#125;,500),render=anime(&#123;duration:1/0,update:function()&#123;ctx.clearRect(0,0,canvasEl.width,canvasEl.height)&#125;&#125;);document.addEventListener(tap,function(e)&#123;\"sidebar\"!==e.target.id&amp;&amp;\"toggle-sidebar\"!==e.target.id&amp;&amp;\"A\"!==e.target.nodeName&amp;&amp;\"IMG\"!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))&#125;,!1),setCanvasSize(),window.addEventListener(\"resize\",setCanvasSize,!1)&#125;\"use strict\";function updateCoords(e)&#123;pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top&#125;function setParticuleDirection(e)&#123;var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return&#123;x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)&#125;&#125;function createParticule(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function()&#123;ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()&#125;,a&#125;function createCircle(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color=\"#F00\",a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function()&#123;ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1&#125;,a&#125;function renderParticule(e)&#123;for(var t=0;t&lt;e.animatables.length;t++)&#123;e.animatables[t].target.draw()&#125;&#125;function animateParticules(e,t)&#123;for(var a=createCircle(e,t),n=[],i=0;i&lt;numberOfParticules;i++)&#123;n.push(createParticule(e,t))&#125;anime.timeline().add(&#123;targets:n,x:function(e)&#123;return e.endPos.x&#125;,y:function(e)&#123;return e.endPos.y&#125;,radius:0.1,duration:anime.random(1200,1800),easing:\"easeOutExpo\",update:renderParticule&#125;).add(&#123;targets:a,radius:anime.random(80,160),lineWidth:0,alpha:&#123;value:0,easing:\"linear\",duration:anime.random(600,800)&#125;,duration:anime.random(1200,1800),easing:\"easeOutExpo\",update:renderParticule,offset:0&#125;)&#125;function debounce(e,t)&#123;var a;return function()&#123;var n=this,i=arguments;clearTimeout(a),a=setTimeout(function()&#123;e.apply(n,i)&#125;,t)&#125;&#125;var canvasEl=document.querySelector(\".fireworks\");if(canvasEl)&#123;var ctx=canvasEl.getContext(\"2d\"),numberOfParticules=30,pointerX=0,pointerY=0,tap=\"mousedown\",colors=[\"#FF1461\",\"#18FF92\",\"#5A87FF\",\"#FBF38C\"],setCanvasSize=debounce(function()&#123;canvasEl.width=2*window.innerWidth,canvasEl.height=2*window.innerHeight,canvasEl.style.width=window.innerWidth+\"px\",canvasEl.style.height=window.innerHeight+\"px\",canvasEl.getContext(\"2d\").scale(2,2)&#125;,500),render=anime(&#123;duration:1/0,update:function()&#123;ctx.clearRect(0,0,canvasEl.width,canvasEl.height)&#125;&#125;);document.addEventListener(tap,function(e)&#123;\"sidebar\"!==e.target.id&amp;&amp;\"toggle-sidebar\"!==e.target.id&amp;&amp;\"A\"!==e.target.nodeName&amp;&amp;\"IMG\"!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))&#125;,!1),setCanvasSize(),window.addEventListener(\"resize\",setCanvasSize,!1)&#125;; 打开 themes/next/layout/_layout.swig，在 &lt;/body&gt; 上面写下如下代码： 12345&#123;% if theme.fireworks %&#125; &lt;canvas class=\"fireworks\" style=\"position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;\" &gt;&lt;/canvas&gt; &lt;script type=\"text/javascript\" src=\"//cdn.bootcss.com/animejs/2.2.0/anime.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"/js/src/fireworks.js\"&gt;&lt;/script&gt;&#123;% endif %&#125; 打开主题配置文件，在里面最后写下： 12# Fireworksfireworks: true 动态背景 next 主题在 5.1.1 以上 打开 next/layout/_layout.swig文件 在 &lt;/body&gt; 之前添加如下代码，不要放在 &lt;/head&gt; 的后面： 1234&#123;% if theme.canvas_nest %&#125;&lt;script type=\"text/javascript\"color=\"0,0,255\" opacity='0.7' zIndex=\"-2\" count=\"99\" src=\"//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js\"&gt;&lt;/script&gt;&#123;% endif %&#125; 打开主题配置文件 /next/_config.yml 搜素 canvas_nest，将 false 改为 true 即可。 next 主题在 5.1.1 以下 打开 next/layout/_layout.swig 文件 在 &lt;/body&gt; 之前添加如下代码，不要放在 &lt;/head&gt; 的后面： 1234&#123;% if theme.canvas_nest %&#125;&lt;script type=\"text/javascript\"color=\"0,0,255\" opacity='0.7' zIndex=\"-2\" count=\"99\" src=\"//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js\"&gt;&lt;/script&gt;&#123;% endif %&#125; 打开主题配置文件 /next/_config.yml 在里面添加如下代码：(可以放在最后面) 123456# --------------------------------------------------------------# background settings# --------------------------------------------------------------# add canvas-nest effect# see detail from https://github.com/hustcc/canvas-nest.jscanvas_nest: true 配置项说明 color：线条颜色, 默认: ‘0,0,0’；三个数字分别为 (R,G,B) opacity: 线条透明度（0~1）, 默认: 0.5 count: 线条的总数量, 默认: 150 zIndex: 背景的 z-index 属性，css 属性用于控制所在层的位置, 默认: -1 修改文章不透明度 设置了动态背景后，动态线条会干扰到文章的阅读，所以就需要调整文章背景的不透明度了。 修改 themes\\next\\source\\css\\ _custom\\custom.styl 文件，在后面添加如下代码： 1234567.main-inner &#123; margin-top: 60px; padding: 60px 60px 60px 60px; background: #fff; opacity: 0.8; min-height: 500px;&#125; 配置项说明 background: #fff; 白色 opacity: 0.8; 不透明度 自动更换背景图片 和修改动态背景类似。 自动更换背景是修改添加背景的 css 样式来实现。图片来源是： 1https://source.unsplash.com/ 这个网站不仅免费提供了很多高清美图，而且还提供 api 接口调用，非常良心。这里实现的原理也是调用了这个网站的接口。 修改 themes\\next\\source\\css\\ _custom\\custom.styl 文件，添加以下代码： 123456body &#123; background:url(https://source.unsplash.com/random/1600x900); background-repeat: no-repeat; background-attachment:fixed; background-position:50% 50%;&#125; 如果不喜欢这个网址提供的图片做背景，可以修改url()里面的路径。repeat、attachment、position就是调整图片的位置、不重复出现、不滚动等等。 静态背景 打开博客根目录 /themes/next/source/css/_custom/custom.styl 文件，编辑如下： 1234567// Custom styles.body &#123; background-image: url(/images/background.png); background-attachment: fixed; // 不随屏幕滚动而滚动 background-repeat: repeat; // 如果背景图不够屏幕大小则重复铺，改为no-repeat则表示不重复铺 background-size: contain; // 等比例铺满屏幕&#125; 然后将背景图命名为 background.png 并放入主题根目录 source/images 下。 修改主题颜色 找到 博客根目录\\themes\\next\\source\\css\\_custom\\custom.styl 并打开 如下列出了蓝色主题的参考代码，可以直接使用： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273// 文章内链接文本样式 .post-body p a&#123; color: #0593d3; border-bottom: none; border-bottom: 1px solid #0593d3; &amp;:hover &#123; color: #fc6423; border-bottom: none; border-bottom: 1px solid #fc6423; &#125; &#125;// 修改选中字符的颜色/* webkit, opera, IE9 */::selection &#123; background: #49b1f5; color: #fff; &#125;/* firefox */::-moz-selection &#123; background: #49b1f5; color: #fff; &#125;// 修改网站头部颜色.headband &#123; height: 3px; background: #49b1f5;&#125;.site-meta &#123; padding: 20px 0; color: #fff; background: #49b1f5;&#125;.site-subtitle &#123; margin-top: 10px; font-size: 13px; color: #ffffff;&#125;// 修改按键（button）样式.btn &#123; color: #49b1f5; background: #fff; border: 2px solid #49b1f5;&#125;// 按键（button）点击时样式.btn:hover &#123; border-color: #49b1f5; color: #fff; background: #49b1f5;&#125;// 鼠标移动至文章标题时的效果.posts-expand .post-title-link::before &#123; content: \"\"; position: absolute; width: 100%; height: 2px; bottom: 0; left: 0; background-color: #49b1f5; visibility: hidden; -webkit-transform: scaleX(0); -moz-transform: scaleX(0); -ms-transform: scaleX(0); -o-transform: scaleX(0); transform: scaleX(0); transition-duration: 0.2s; transition-timing-function: ease-in-out; transition-delay: 0s;&#125;","categories":[{"name":"Blog","slug":"Blog","permalink":"https://zhangxiaocn.github.io/categories/Blog/"}],"tags":[{"name":"Blog","slug":"Blog","permalink":"https://zhangxiaocn.github.io/tags/Blog/"},{"name":"Hexo","slug":"Hexo","permalink":"https://zhangxiaocn.github.io/tags/Hexo/"},{"name":"美化","slug":"美化","permalink":"https://zhangxiaocn.github.io/tags/%E7%BE%8E%E5%8C%96/"}]},{"title":"我初学 C 的代码保留","slug":"my-c-memory","date":"2019-10-27T13:23:55.000Z","updated":"2019-10-29T13:26:24.407Z","comments":true,"path":"2019/10/27/my-c-memory/","link":"","permalink":"https://zhangxiaocn.github.io/2019/10/27/my-c-memory/","excerpt":"","text":"以下内容为本人初学 C 的时候所写的部分代码，有些程序现在看起来写的真的很烂哈哈，但是舍不得删除呐，最后还是将它们保留了下来。。。这算不算是松鼠症？？ 求和问题 求 1 + 2! + 3! + … + 20! 的和： 123456789int sum(void) &#123; float a = 1, b = 0, i; for (i = 1; i &lt;= 20; i++) &#123; a = a * i; b = b + a; &#125; printf(\"1 + 2! + 3! ... + 20! = %.0f\\n\", b); return 0;&#125; 求 1 + 2 + … + 100 的和： 123456789101112int sum(void) &#123; int a, b = 0; a = 1;loop: if (a &lt;= 100) &#123; b = b + a; a++; goto loop; &#125; printf(\"1 + 2 + ... + 100 的和为：%d\\n\", b); return 0;&#125; 有一分数序列：2/1，3/2，5/3，8/5，13/8，21/13 … 求出这个数列的前 20 项之和： 123456789101112int sum(void) &#123; int i; float a = 2, b = 1, c = 0, d; for (i = 1; i &lt;= 20; i++) &#123; c = a / b + c; d = a; a = a + b; b = d; &#125; printf(\"这个数列的前20项之和为：%f\\n\", c); return 0;&#125; 求序列 S = 2/1 + 3/2 + 5/3 + 8/5 + 13/8 + …… 前 n 项和： 123456789101112131415int sum(void) &#123; float S = 0, s1 = 2, s2 = 1; int a, n; printf(\"请输入 n 的值：\"); scanf(\"%d\", &amp;n); for (a = 0; a &lt; n; a++) &#123; S = (s1 / s2) + S; s2 = s1; s1 = (2 * s1) - 1; &#125; printf(\"S = 2/1 + 3/2 + 5/3 + 8/5 + 13/8 + …… 前 n 项和为：%f\", S); printf(\"\\n\"); return 0;&#125; 求 1 到 100 之间的奇数之和，偶数之和： 123456789101112int sum(void) &#123; int i, sum1 = 0, sum2 = 0; for (i = 1; i &lt;= 100; i++) &#123; if (i % 2 != 0) sum1 += i; else sum2 += i; &#125; printf(\"1~100 的奇数和为：%d\\n\", sum1); printf(\"1~100 的偶数和为：%d\\n\", sum2); return 0;&#125; 阶乘问题 求 n 的阶乘 n!： 1234567891011int factorial(void) &#123; int i = 1, s = 1, n; printf(\"请输入需要求阶乘的数字：\"); scanf(\"%d\", &amp;n); do &#123; s = s * i; i++; &#125; while (i &lt;= n); printf(\"%d! = %d\\n\", n, s); return 0;&#125; 12345678int factorial(void) &#123; int i, s, n; printf(\"请输入需要求阶乘的数字：\"); scanf(\"%d\", &amp;n); for (i = 1, s = 1; i &lt;= n; i++) s = s * i; printf(\"%d! = %d\\n\", n, s); return 0;&#125; 1234567891011int factorial(void) &#123; int i = 1, s = 1, n; printf(\"请输入需要求阶乘的数字：\"); scanf(\"%d\", &amp;n); while (i &lt;= n) &#123; // 一直算到 i &gt; n 时循环结束，输出 s = s * i; i++; &#125; printf(\"%d! = %d\\n\", n, s); return 0;&#125; 素数问题 判断输入的数字是否为素数： 1234567891011121314151617int prime_number(void) &#123; int a = 0, i; int n = 0; printf(\"输入一个整数：\"); scanf(\"%d\", &amp;n); for (i = 2; i &lt; n; i++) &#123; if (n % i == 0) &#123; a++; &#125; &#125; if (a == 0) &#123; printf(\"%d 是素数\\n\", n); &#125; else &#123; printf(\"%d 不是素数\\n\", n); &#125; return 0;&#125; 求出 100~200 之间的所有素数： 1234567891011121314151617int prime_number(void) &#123; int m, i, a = 0, b = 0; printf(\"\\n\"); printf(\"100~200 之间的所有素数为：\"); for (m = 101; m &lt;= 200; m++) &#123; for (i = 2; i &lt; m; i++) &#123; if (m % i == 0) a++; &#125; if (a == 0) &#123; printf(\"%-4d\", m); b++; &#125; else a = 0; &#125; printf(\"\\n这些素数一共有 %d 个\", b); return 0;&#125; 求 100~300 之间所有素数之和： 1234567891011121314151617181920int prime_number(void) &#123; int m, i, a = 0, b = 0, c, d = 0; printf(\"\\n\"); printf(\"100 ~ 300之间所有素数之和为：\"); for (m = 101; m &lt;= 300; m++) &#123; for (i = 2; i &lt; m; i++) &#123; if (m % i == 0) a++; &#125; if (a == 0) &#123; c = m; d = c + d; &#125; else a = 0; &#125; printf(\"%d\", d); printf(\"\\n\"); return 0;&#125; 编写一个程序，从键盘输入一个整数，输出大于且紧随该整数的素数： 1234567891011121314151617181920int prime_number(void) &#123; int a = 0, i, n, m; printf(\"输入一个整数：\"); scanf(\"%d\", &amp;n); m = n + 1;A: for (i = 2; i &lt; m; i++) &#123; if (m % i == 0) &#123; a++; &#125; &#125; if (a == 0) &#123; printf(\"大于且最接近输入的数的素数是：%d\\n\", m); &#125; else &#123; m = m + 1; a = 0; goto A; &#125; return 0;&#125; 1234567891011121314151617int prime_number(void) &#123; int i, m, c; scanf(\"%d\", &amp;m); while (1) &#123; m++; c = 1; for (i = 2; i &lt; m; i++) &#123; if (m % i == 0) &#123; c = 0; break; &#125; &#125; if (c == 1) break; &#125; printf(\"%d\\n\", m); return 0;&#125; 排序问题 从键盘输入 10 个整数，编程求出其中的最大值和最小值，并输出结果： 1234567891011121314int sort(void) &#123; int max, min, m[10], i; printf(\"请输出10个数：\"); for (i = 0; i &lt; 10; i++) scanf(\"%d\", &amp;m[i]); // 输入 10 个数字，保存到 m[i] 中 max = min = m[0]; // 定义最值 for (i = 1; i &lt; 10; i++) if (max &lt; m[i]) // m[i] 依次与最值比较，得出最大值 max max = m[i]; else if (min &gt; m[i]) // m[i] 依次与最值比较，得出最小值 min min = m[i]; printf(\"最大值 = %d\\n最小值 = %d\", max, min); return 0;&#125; 将输入的五个整数按照从小到大顺序排列： 12345678910111213141516171819int sort(void) &#123; int a[5]; int i, j, t; printf(\"请输入5个数：\"); for (i = 0; i &lt; 5; i++) scanf(\"%d\", &amp;a[i]); printf(\"\\n\"); for (j = 0; j &lt; 4; j++) // 进行 4 次循环，实现 4 趟比较 for (i = 0; i &lt; 4 - j; i++) // 在每一趟比较中进行 4－1 次比较 if (a[i] &gt; a[i + 1]) // 相邻两个数比较 &#123; t = a[i]; a[i] = a[i + 1]; a[i + 1] = t; &#125; printf(\"排序后的数据为：\"); for (i = 0; i &lt; 5; i++) printf(\"%d \", a[i]); printf(\"\\n\"); return 0;&#125; 输出图像 输出一个菱形： 1234567891011121314int diamond(void) &#123; int a, b, c; for (a = 0; a &lt; 4; a++) &#123; for (b = 0; b &lt;= 2 - a; b++) printf(\" \"); for (c = 0; c &lt;= 2 * a; c++) printf(\"*\"); printf(\"\\n\"); &#125; for (a = 0; a &lt;= 2; a++) &#123; for (b = 0; b &lt;= a; b++) printf(\" \"); for (c = 0; c &lt;= 4 - 2 * a; c++) printf(\"*\"); printf(\"\\n\"); &#125; return 0;&#125; 输出一个行数可调的菱形： 12345678910int diamond(void) &#123; int n, i, j; scanf(\"%d\", &amp;n); // 输入一个 n，则输出 2*n+1 行 for (i = -n; i &lt;= n; i++) &#123; for (j = 1; j &lt;= abs(i); j++) printf(\" \"); for (j = 1; j &lt;= 2 * n + 1 - 2 * abs(i); j++) printf(\"*\"); printf(\"\\n\"); &#125; return 0;&#125; 输出空心菱形： 12345678910111213141516171819202122232425262728293031323334353637int diamond(void) &#123; int i, j, k, line, m; printf(\"请输入行数：\"); scanf(\"%d\", &amp;line); m = (line + 1) / 2; for (i = 1; i &lt;= m; i++) &#123; for (k = 0; k &lt; m - i; k++) &#123; printf(\" \"); &#125; printf(\"*\"); if (i == 1) &#123; printf(\"\\n\"); continue; &#125; for (j = 0; j &lt; 2 * i - 3; j++) &#123; printf(\" \"); &#125; printf(\"*\"); printf(\"\\n\"); &#125; for (i = m - 1; i &gt; 0; i--) &#123; for (k = 0; k &lt; m - i; k++) &#123; printf(\" \"); &#125; printf(\"*\"); if (i == 1) &#123; printf(\"\\n\"); continue; &#125; for (j = 0; j &lt; 2 * i - 3; j++) &#123; printf(\" \"); &#125; printf(\"*\"); printf(\"\\n\"); &#125; return 0;&#125; 输出一个正方形中的空心菱形（行数可控）： 123456789101112131415161718192021int diamond(void) &#123; int n, i, j; printf(\"请输入这个空心菱形的行数：\"); scanf(\"%d\", &amp;n); printf(\"\\n\"); for (i = -(n / 2); i &lt;= n / 2; i++) &#123; if (i == -(n / 2) || i == (n / 2)) &#123; //第一行和最后一行 for (j = 1; j &lt;= n; j++) &#123; printf(\"*\"); &#125; printf(\"\\n\"); &#125; else &#123; for (j = 1; j &lt;= abs(i) + 1; j++) printf(\"*\"); for (j = 1; j &lt;= (n - 2 * (abs(i) + 1)); j++) printf(\" \"); for (j = 1; j &lt;= abs(i) + 1; j++) printf(\"*\"); printf(\"\\n\"); &#125; &#125; printf(\"\\n\"); return 0;&#125; 文字玩法 输入一个 5 位数，判断它是不是回文数： 1234567891011121314151617181920int palindrome(void) &#123; int x; // 带输入的数 int g, w, s, q; // 分别表示的是个位、万位、十位、千位 printf(\"请输入一个 5 位数：\"); scanf(\"%d\", &amp;x); if (x &gt; 99999 || x &lt; 10000) printf(\"您输入的 %d 不是一个 5 位数\\n\", x); else &#123; g = x % 10; w = x / 10000; s = (x % 100) / 10; q = (x % 10000) / 1000; if (g == w &amp;&amp; s == q) printf(\"%d 是一个回文数\\n\", x); else printf(\"%d 不是一个回文数\\n\", x); &#125; return 0;&#125; 输出 9×9 口诀表： 123456789101112int table(void) &#123; int i, j, result; printf(\"\\n\"); for (i = 1; i &lt; 10; i++) &#123; for (j = 1; j &lt; 10; j++) &#123; result = i * j; printf(\"%d*%d=%-3d\", i, j, result); // -3d 表示左对齐，占 3 位 &#125; printf(\"\\n\"); // 每一行后换行 &#125; return 0;&#125;","categories":[{"name":"C","slug":"C","permalink":"https://zhangxiaocn.github.io/categories/C/"}],"tags":[{"name":"回忆","slug":"回忆","permalink":"https://zhangxiaocn.github.io/tags/%E5%9B%9E%E5%BF%86/"},{"name":"C","slug":"C","permalink":"https://zhangxiaocn.github.io/tags/C/"}]},{"title":"Hexo yilia 主题的启用及设置","slug":"hexo-theme-yilia","date":"2019-10-25T13:57:17.000Z","updated":"2019-10-29T13:26:09.400Z","comments":true,"path":"2019/10/25/hexo-theme-yilia/","link":"","permalink":"https://zhangxiaocn.github.io/2019/10/25/hexo-theme-yilia/","excerpt":"","text":"yilia 主题作者已经不维护了，还有好多坑没有填完，在此记录一下 主题地址：https://github.com/litten/hexo-theme-yilia 本文章同步更新地址：https://www.cnblogs.com/zhangxiaochn/p/Hexo_Theme_Yilia.html 主题的启用 下载并启用 进入命令行，下载 yilia 主题，输入： 1git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 修改站点配置文件 _config.yml，找到如下代码： 12## Themes: https://hexo.io/themes/theme: landscape 将 landscape 修改为 yilia 即可。 修改语言 打开站点配置文件，搜索language，找到如下代码： 123author:language:timezone: 在 language 后面输入 zh-CN。 注意：冒号后面必须有一个空格。 主题相关设置 “所有文章”按钮的安装 首先使用命令 node -v 检查版本是不是大于 6.2 在博客根目录执行以下命令： 1npm i hexo-generator-json-content --save 在博客配置文件 _config.yml 最下面加上： 123456789101112131415161718jsonContent: meta: false pages: false posts: title: true date: true path: true text: false raw: false content: false slug: false updated: false comments: false link: false permalink: false excerpt: false categories: false tags: true 添加图片资源文件夹 路径为 themes/yilia/source/ 下，可添加一个 assets 文件夹，里面存放图片资源即可 需要添加头像或者微信/支付宝二维码图片，直接引用即可。路径为 themes/yilia/_config.yml 。 12345678# 微信二维码图片weixin: /assets/img/wechat.png# 头像图片avatar: /assets/img/head.jpg# 网页图标favicon: /assets/img/head.jpg 文章显示摘要 在你 MD 格式文章正文插入 &lt;!-- more --&gt; 即可，只会显示它之前的，此后的就不显示，点击文章标题，全文阅读才可看到，同时注释掉文件 themes/yilia/_config.yml 里的： 1# excerpt_link: more 文章显示目录 增加文章目录 TOC ( table of content )，方便阅读文章，在 themes/yilia/_config.yml 中进行配置 toc: 2 即可，它会将你 Markdown 语法的标题，生成目录，目录查看在右下角。 增加归档菜单 修改 themes/yilia/_config.yml 内容： 123menu: 主页: / 归档: /archives/index.html 修复失效的微信分享二维码 打开 themes\\yilia\\layout\\_partial\\post\\share.ejs 文件 把第49行中的 //pan.baidu.com/share/qrcode?url= 修改为： 1//api.qrserver.com/v1/create-qr-code/?size=150x150&amp;data= 更改左侧昵称字体 在 themes\\yilia\\source\\main.0cf68a.css 文件里面修改，找到 header-author ，修改里面的 font-family ，改成： 1font-family:\"Times New Roman\",Georgia,Serif 左侧显示总文章数 打开 themes\\yilia\\layout\\_partial\\left-col.ejs 文件 在： 1234567&lt;nav class=&quot;header-menu&quot;&gt; &lt;ul&gt; &lt;% for (var i in theme.menu)&#123; %&gt; &lt;li&gt;&lt;a href=&quot;&lt;%- url_for(theme.menu[i]) %&gt;&quot;&gt;&lt;%= i %&gt;&lt;/a&gt;&lt;/li&gt; &lt;%&#125;%&gt; &lt;/ul&gt;&lt;/nav&gt; 后面添加： 123&lt;nav&gt; 总文章数 &lt;%=site.posts.length%&gt;&lt;/nav&gt; 添加字数统计 首先安装 hexo-wordcount 使用如下命令安装： 1npm i --save hexo-wordcount Node 版本7.6.0之前,请安装 2.x 版本 (Node.js v7.6.0 and previous) 1npm install hexo-wordcount@2 --save 然后在 themes\\yilia\\layout\\_partial\\left-col.ejs中添加： 123&lt;nav&gt; 总字数 &lt;span class=&quot;post-count&quot;&gt;&lt;%= totalcount(site, &apos;0,0.0a&apos;) %&gt;&lt;/span&gt;&lt;/nav&gt; 添加位置在如下代码的下面： 123&lt;nav&gt; 总文章数 &lt;%=site.posts.length%&gt;&lt;/nav&gt; 编辑 themes\\yilia\\layout\\_partial\\article.ejs 在header下面加入： 123&lt;div align=&quot;center&quot; class=&quot;post-count&quot;&gt; 字数：&lt;%= wordcount(post.content) %&gt;字 | 预计阅读时长：&lt;%= min2read(post.content) %&gt;分钟&lt;/div&gt; 即可显示单篇字数和预计阅读时长。 添加来必力(livere)评论系统 yilia 默认带了几个系统，但是没有来必力，所以可以自己加 首先是去注册来必力，然后获取到自己的 id 新建 themes\\yilia\\layout\\_partial\\comment\\livere.ejs 文件，输入如下内容： 123456789101112131415161718&lt;!-- 来必力City版安装代码 --&gt;&lt;div id=&quot;lv-container&quot; data-id=&quot;city&quot; data-uid=&quot;&lt;%=theme.livere_uid%&gt;&quot;&gt;&lt;script type=&quot;text/javascript&quot;&gt; (function(d, s) &#123; var j, e = d.getElementsByTagName(s)[0]; if (typeof LivereTower === &apos;function&apos;) &#123; return; &#125; j = d.createElement(s); j.src = &apos;https://cdn-city.livere.com/js/embed.dist.js&apos;; j.async = true; e.parentNode.insertBefore(j, e); &#125;)(document, &apos;script&apos;);&lt;/script&gt;&lt;noscript&gt;为正常使用来必力评论功能请激活JavaScript&lt;/noscript&gt;&lt;/div&gt;&lt;!-- City版安装代码已完成 --&gt; 然后编辑 themes\\yilia\\layout\\_partial\\article.ejs 文件，找到：&lt;% if (!index &amp;&amp; post.comments){ %&gt; ，添加： 1234567&lt;% if (theme.livere)&#123; %&gt;&lt;%- partial(&apos;comment/livere&apos;, &#123;key: post.slug,title: post.title,url: config.url+url_for(post.path)&#125;) %&gt;&lt;% &#125; %&gt; 在主题配置文件 themes\\yilia\\_config.yml 中添加以下内容： 12livere: truelivere_uid: 你的id 关闭信息收集（自选） 关于访问 litten.me:9005 的问题，这个主题的作者之前为了更好地完善这个主题，有时候会收集用户的客户端信息，详情请见 https://github.com/litten/hexo-theme-yilia/issues/528 ，如果不想被统计，就将 themes\\yilia\\source-src\\js\\report.js 里面的内容清空。不过这个请求是异步的，不会影响博客加载速度，而且作者已经不维护了，所以关不关都行。","categories":[{"name":"Blog","slug":"Blog","permalink":"https://zhangxiaocn.github.io/categories/Blog/"}],"tags":[{"name":"Blog","slug":"Blog","permalink":"https://zhangxiaocn.github.io/tags/Blog/"},{"name":"Hexo","slug":"Hexo","permalink":"https://zhangxiaocn.github.io/tags/Hexo/"},{"name":"美化","slug":"美化","permalink":"https://zhangxiaocn.github.io/tags/%E7%BE%8E%E5%8C%96/"}]},{"title":"Hexo+Github 创建个人博客","slug":"create-blog","date":"2019-10-25T11:54:41.000Z","updated":"2019-10-29T13:29:40.141Z","comments":true,"path":"2019/10/25/create-blog/","link":"","permalink":"https://zhangxiaocn.github.io/2019/10/25/create-blog/","excerpt":"","text":"安装及配置 首先安装如下软件，安装过程无脑点击下一步即可。 Git Node.js：建议下载 LTS 长期支持版 安装完成后，在 cmd 里输入 git version 即可查看 git 当前版本。输入 node -v 即可查看 node.js 当前版本。 接下来，新建一个文件夹，创建的位置任选。该文件夹主要用来存放博客的所有文件。然后进入该文件夹（这里就是博客文件夹的根目录，后文很多地方会用到），右键选择 Git Bash Here 选项。 在弹出的窗口中，输入 npm config set registry https://registry.npm.taobao.org 切换为淘宝源，从而加快下载速度。 接着，输入 npm i -g hexo 安装 hexo。 安装完成后，在当前窗口中，输入 hexo -v 即可查看 hexo 当前版本。 然后，我们输入命令 hexo init，初始化 hexo ，完成后打开我们的博客文件夹，即可看到该文件夹里有很多的文件了，这些都是我们搭建博客所需要的文件。 github 配置 首先进入 github 官网，注册新账号，账号名称一定要想好了再填，不然你会后悔的。。。 注册成功后点击右上角的 New repository，在 Reposotory name 栏中填入 yourname.github.io （yourname 改为你账号的名称），然后点击 Create reposutory。 接着我们回到博客文件夹的根目录，右键选择 Git Bash Here 选项，配置 github 账户的信息，输入： 12git config --global user.name &quot;yourname&quot;git config --global user.email &quot;youremail&quot; 命令中的 yourname 和 youremail 分别改为你的账户名以及你创建该账户的邮箱。 然后输入cd ~/.ssh 检查电脑中的 SSH Key，会出现提示： No such file or directory 。 接下来我们开始创建 SSH。回到博客文件夹的根目录，右键选择 Git Bash Here 选项，输入 ssh-keygen -t rsa -C &quot;youremail@example.com，将 youremail@example.com 改为你的账户邮箱。一路回车即可。 紧接着输入： 12cd ~/.sshcat id_rsa.pub 将获取的 ssh 复制下来，打开 github 首页，点击页面右上角的头像，选择 Settings，在下面的选项中找到 SSH and GPG keys 。点击 New SSH key ，Title 里的内容可以自定义，Key 里粘贴刚才复制的内容。点击 add key。 返回到博客文件夹的根目录，右键选择 Git Bash Here 选项，输入 ssh -T git@github.com 。 若弹出 Are you sure you want to continue connecting (yes/no)? 时输入 yes 并回车。 接着出现 Hi xxx! You've successfully authenticated, but GitHub does not provide shell access. 则操作成功。 博客配置 打开你的博客文件夹，找到 _config.yml 文件并打开，在最后修改并添加如下代码： 1234deploy: type: git repo: https://github.com/YourgithubName/YourgithubName.github.io.git branch: master 将 YourgithubName 改为你的 github 账号名。保存文件。 回到博客文件夹的根目录，右键选择 Git Bash Here 选项，分别执行以下命令： 123hexo cleanhexo ghexo s 接着打开浏览器，在浏览器中输入 http://localhost:4000 即可看到你的本地博客了。 博客上传 在博客文件夹的根目录，右键选择 Git Bash Here 选项，输入 npm install hexo-deployer-git --save 安装部署到 github 的插件。 然后执行以下命令： 123hexo cleanhexo ghexo d 中途可能会出现弹窗需要输入 github 账号和密码。输入完即可。 接下来等待十分钟左右，等待 github 将博客文件配置完成。 在浏览器中输入 https://yourgithubname.github.io （yourgithubname 为你的 github 账号名）即可看到你的个人博客了。 创建文章 博客搭建完成后，在博客文件夹的根目录，右键选择 Git Bash Here 选项，输入 hexo n yourtitle （yourtitle 改为你自定义的文章标题）即可创建文章，文章保存的路径在 博客文件夹根目录/source/_posts 文件夹中，文件格式为 markdown 格式，想要写文章的朋友可以自学 markdown 语法，然后就可以打开这个文件进行写作了。 写作完成后，进入你的博客文件夹根目录，右键选择 Git Bash Here 选项 ，输入： 123hexo cleanhexo ghexo d 即可上传到 github。 绑定域名 不需要更换域名的朋友可以跳过这一节。 GitHub Pages 支持使用自己的域名，喜欢个性化的朋友可以选择一个合适的域名绑定博客。 以下用阿里云举例。 首先购买一个域名，购买完成后，如果没有进行过实名认证的话，一定要进行实名认证，也就是域名状态那里。 进行实名认证后，进行域名解析。首先进入博客文件夹根目录，右键选择 Git Bash Here 选项，然后输入 ping @yourname.github.io ，得到 IP 并复制。 进入阿里云控制台，点击域名后面的 解析，添加如下记录： 记录类型 主机记录 记录值 TTL CNAME @ yourname.github.io 10分钟 A www yourIP 10分钟 将 yourname 改为你的 github 账户名，将 yourIP 改为你刚才复制的 IP。其他保持默认即可。 进入 github，打开刚刚创建的仓库，打开 Setting ，找到 Github pages ，在 Custom domain 里输入你购买的域名，例如: www.yourname.com ( www. 可以不写 ) ，点击 save ，勾选下面的 Enforce HTTPS 选项。 进入博客文件夹根目录，找到 source ，在里面创建一个文本文档，输入你购买的域名，例如： www.yourname.com ( www. 可以不写 )，保存后重命名为 CNAME ，并将文件后缀名删除。 然后进入博客文件夹根目录，右键选择 Git Bash Here 选项，输入 hexo d -g 即可。等待 10 分钟左右时间便可以用新域名访问博客。 hexo 常用指令 平常我们用到的指令如下： hexo clean：清除缓存文件和已生成的静态文件。 hexo g：生成静态文件。 hexo s：启动服务器。默认情况下，访问网址为： http://localhost:4000/ 。 hexo d：部署网站。 hexo v：显示 Hexo 版本。 可以进入Hexo文档 查看更多指令。 博客配置文件详解 “配置文件” 为博客根目录的 _config.yml 文件 部分注释来自互联网 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Site（标题等必填）#网站标题title:#网站副标题subtitle:#网站描述description:#作者昵称author:#网站语言，默认英语，设置简体中文language: zh-CN#时区，默认电脑时区timezone: Asia/Shanghai# URL#如果网站是放在子目录中，将url设置成'http://yoursite.com/child'，将root设置成'/child/'## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'#网址（输入你的GitHub Pages地址）url: http://用户名.github.io#网站根目录。如果网站是放在子目录中，将root设置成'子目录名'root: /#文章链接地址格式 。即文章存放的目录。（**注意**：为方便网络爬虫抓取博客信息，一般都会把网址设置成“三段”，而Hexo默认为“域名:年:月:日:标题”五段。强烈建议修改为**:year:month:day/:title/**以便于抓取。）permalink: :year:month:day/:title/permalink_defaults:# Directory#资源文件夹，放在里面的文件会上传到github中source_dir: source#公共文件夹，存放生成的静态文件public_dir: public#标签文件夹，默认是tags。实际存放在source/tags中。tag_dir: tagsrss_dir: rss#档案文件夹，默认是archives。archive_dir: archives#分类文件夹，默认是categories。实际存放在source/categories中。category_dir: categories#代码文件夹，默认是downloads/codecode_dir: downloads/code#国际化文件夹，默认跟language相同i18n_dir: :lang#不需要渲染的文件夹或文件夹,格式为[文件名]skip_render:# Writing# 新建博文（帖子）的默认名称# File name of new postsnew_post_name: :title.md#默认布局模板是post，而不是draft和pagedefault_layout: post#是否将标题转换成标题形式（首字母大写）titlecase: false # Transform title into titlecase#在新标签页面中打开网页external_link: true # Open external links in new tabfilename_case: 0#是否渲染草稿render_drafts: false#启动 Asset 文件夹post_asset_folder: false#把链接改为与根目录的相对位址relative_link: false#显示未来的文章future: true#代码块的设置highlight:enable: true # 使用代码高亮line_number: true # 显示行号auto_detect: true # 自动检测语言tab_replace:# Home page setting# path: Root path for your blogs index page. (default = '')# per_page: Posts displayed per page. (0 = disable pagination)# order_by: Posts order. (Order by date descending by default)index_generator:path: ''#每页文章数量per_page: 10#排序依据order_by: -date# Category &amp; Tag#默认分类default_category: uncategorized#分类别名category_map:#标签别名tag_map:# Date / Time format#Hexo 使用 Moment.js 来解析和显示时间。## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page# Extensions 拓展插件配置## Plugins: https://hexo.io/plugins/#主题配置## Themes: https://hexo.io/themes/#选择主题,默认为landscapetheme: landscape# ---------------下面选项需要对应插件的支持---------------# 部署配置## Docs: https://hexo.io/docs/deployment.htmldeploy:type: gitrepo: git@github.com:用户名/用户名.github.io.gitbranch: master# 配置RSSfeed:#feed 类型 (atom/rss2)type: atom#rss 路径path: atom.xml#在 rss 中最多生成的文章数(0显示所有)limit: 0# 自定义站点内容搜索# 需要先安装插件：# npm install hexo-generator-search --savesearch:path: search.xml# 如只想索引文章，可设置为postfield: all# ---------------------------------------------------","categories":[{"name":"Blog","slug":"Blog","permalink":"https://zhangxiaocn.github.io/categories/Blog/"}],"tags":[{"name":"Blog","slug":"Blog","permalink":"https://zhangxiaocn.github.io/tags/Blog/"},{"name":"Hexo","slug":"Hexo","permalink":"https://zhangxiaocn.github.io/tags/Hexo/"}]}]}